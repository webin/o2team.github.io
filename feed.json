{"title":"Aotu.io","description":"凹凸实验室(Aotu.io) 始建于2015年，是一个年轻基情的技术社区组织。<br/>O2面向多终端技术体系，致力于构建沉淀与分享包括但不限于交互、页面制作技巧、前端开发、原生APP开发等方面的专业知识及案例。","language":"zh-cn","link":"https://aotu.io","pubDate":"Fri, 24 Mar 2017 10:00:00 GMT","lastBuildDate":"Fri, 07 Apr 2017 10:50:16 GMT","generator":"hexo-generator-json-feed","webMaster":"凹凸实验室","items":[{"title":"实现一个简单但有趣的AR效果（Web）","link":"https://aotu.io/notes/2017/03/24/webar/","description":"增强现实（Augmented Reality，简称AR）：是一种实时地计算摄影机影像的位置及角度并加上相应图像、视频、3D模型的技术，这种技术的目标是在屏幕上把虚拟世界套在现实世界并进行互动。 本文将让你了解“如何通过 Web 技术实现一个简单但有趣的 AR 效果”。 实现分析正如文章开头说道：AR 是将真实环境与虚拟物体实时地叠加到一个画面。因此我们需要通过摄像头实时获取真实环境，并通过识别算法识别与分析真实环境中特定的物体，然后结合得到的数据，将虚拟物体以某种方式结合到画面中。 结合我们的案例，可得出以下步骤： 获取视频源 分析源，并识别出 Marker 位置 将虚拟物体叠加在 Marker 上 将最终画面显示在屏幕上 下面我们就根据以上步骤逐点分析。 技术分析获取视频源不依赖 Flash 或 Silverlight，我们使用 navigator.getUserMedia() API，该 API 允许 web 应用获取用户的摄像头与麦克风流（stream）。 123456789101112131415161718192021222324252627282930313233&lt;!-- 若不加 autoplay，则会停留在第一帧 --&gt;&lt;video autoplay&gt;&lt;/video&gt;navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;var video = document.querySelector('video');var constraints = &#123; video: true&#125;function successCallback(stream) &#123; // 此处利用该 window.URL 对象的 createObjectURL 方法将 blob 转为 url。 if (window.URL) &#123; video.src = window.URL.createObjectURL(stream); // 用来创建 video 可以播放的 src &#125; else &#123; video.src = stream; &#125;&#125;function errorCallback(error) &#123; console.log('navigator.getUserMedia error: ', error);&#125;if (navigator.getUserMedia) &#123; navigator.getUserMedia(&#123;video: true&#125;, successCallback, errorCallback);&#125; else &#123; console.log('getUserMedia() is not supported in your browser') video.src = 'somevideo.webm'; // fallback.&#125; 上述 API 已不被推荐，建议使用新标准 API：navigator.mediaDevices.getUserMedia()。12345navigator.mediaDevices.getUserMedia(constraints).then(function(stream) &#123; /* use the stream */&#125;).catch(function(err) &#123; /* handle the error */&#125;); 另外，可通过 constraints 参数设置以下选项： 启用 video、audio 二者其一或两者同时启用 匹配摄像头分辨率（若设备拥有不止一个摄像头） 选择前后摄像头 navigator.getUserMedia() 兼容性问题目前 IOS 设备的微信和 Safari 均不支持，较新的安卓和桌面端浏览器均支持。 另外，出于安全问题考虑，Chrome 只支持 HTTPS 页面启用摄像头。因此，我们可以用 Firefox，或者借助一些线上编辑器，如 jsbin、jsFiddle 等进行开发测试。 识别得到视频源后，我们需要对图像中的物体（本案例是 Marker）进行实时识别。下面提供两个可实现识别的库： jsaruco jsartoolkit 正如其名，它们是 aruco 和 artoolkit 的 JavaScript 版本。本文仅对第一个库进行介绍。 ArUco 是一个基于 OpenCV 的 AR 轻量库。 OpenCV（Open Source Computer Vision Library）：是一个跨平台的计算机视觉库。它可用于开发实时的图像处理、计算机视觉以及模式识别程序。 jsaruco 能识别视频每帧画面中的 Marker 位置（含 4 个角坐标）。获取坐标后，我们就能将虚拟物体放在真实环境的适当位置了。关于 jsaruco 的介绍和用法，可到 这里 查看。 结合真实环境和虚拟物体对图像的处理，Canvas（WebGL） 无疑是目前 Web 的最佳选择。 虚拟对象若是 2D 的，则直接利用 Canvas 2D API 在相应坐标上进行绘制。若虚拟对象是 3D 的，则可使用 Three.js 或 A-Frame 等 3D 库（当然，你也可以直接用 WebGL）。 如果你对 Three.js 还不了解，可以看看 《Three.js入门指南》。 Marker 分析每个识别库都有其自身的实现方式。因此，一些 Marker 可能只适用于某个库。对于 jsaruco，它对 Marker 的要求如下： 一个 7x7 的正方形，其外层是“不用”的黑边。内部 5x5 单元格则组成了 ID 信息。其中，每行需要遵循以下模式： white - black - black - black - blackwhite - black - white - white - whiteblack - white - black - black - whiteblack - white - white - white - black 因此，根据上述信息，我们可以得出该库最多可识别 1024（4的5次方） 个 Marker。也就是说：每个 Marker 对应唯一一个 ID，然后我们可以利用 ID 指定显示的虚拟对象。 一个合格的 Marker 应该是这样子： 可通过这个 链接，获取 jsaruco 的更多 Marker。 当然，更先进的图像识别库不仅能识别 Marker，也可以识别你指定的图片，甚至是自然特征跟踪（ Natural Feature Tracking）和 SLAM（Simultaneous Localization and Mapping，即时定位与地图构建）。 自然特征跟踪 SLAM 实现案例建议使用带有摄像头的电脑体验以下案例（注意不要被自己的头像惊艳到~）。 另外，由于以下案例均未要求特定 ID 的 Marker，因此你可以选择以下 Marker（拍照或打印），或者在 这里 挑选一个进行体验。 Marker 想体验以下案例，需要先对某一个 Marker 拍下或打印，然后将其展示在摄像头前。 另外，为了保持文章的简洁，在此就不直接展示以下案例的实现代码。若需要，则直接查看案例源码。 再次提醒：以下案例均在电脑上进行开发测试，未针对移动端设备进行优化测试。 除了第一个案例，其余均以动画的方式展示虚拟元素。 显示 2D 图当你展示团队 Logo 时，链接&gt;&gt;。 显示心跳当你看到“男神/女神”时，链接&gt;&gt;。 显示卡片当需要展示某个人的身份信息时，链接&gt;&gt;。 显示 3D 地球当展示我们的地球母亲时，链接&gt;&gt;。 显示 3D 商品。当展示我们的商品时，链接&gt;&gt;。 最后由于笔者才疏学浅，实现的案例未必完全符合 AR 的要求。但希望通过本文，让大家能对 Web AR 有一定的了解。 参考文档 Augmented Reality in Three.js Three.js入门指南 MDN : MediaDevices.getUserMedia() js-aruco","pubDate":"Fri, 24 Mar 2017 10:00:00 GMT","guid":"https://aotu.io/notes/2017/03/24/webar/","category":"Web开发"},{"title":"轻氧 - React Native 安卓版 V1.0","link":"https://aotu.io/notes/2017/03/03/liteo2-android/","description":"距 轻氧 iOS版上一次发版本已经快一个月。 一个月可以做很多件事情，具有 加藤鹰の右手手速 的男前端童鞋可以做4到5个甚至更多的互动H5活动；但也可以只做一件事情，我们阿尔法突击队三个小伙伴过去这个月就只做了本次的 轻氧 安卓 V1.0，从交互到设计到编码实现再到申请上架。 我们慢，除了因为我们是新手（完全没有安卓 APP 开发经验，其中一名叫马克林的童鞋还是专职的 iOS 开发~），还因为我们足够用心和耐（cai）心（keng）。 我们依然是新技术控，在iOS版本中我们追随了 Swift 3.0，而在本次的安卓版本中我们选择了 React Native，尽管它的 JSX 语法相当的蹩脚丑陋，且版本号还是距离 1.0 相当遥远的 0.4x。 我们没有忘记在公众号（凹凸实验室）里留言召唤安卓版的同学们，所以现在神龙出现了。 版本功能在 iOS 版开发过程中存在版本规划过于粗放导致开发周期拖沓的问题，我们在开发安卓版前细化了版本计划，更细的版本规划可以让我们保持 小步快跑，快速迭代 的敏捷开发理念，通过 上线-反馈-修改-上线 的反复迭代来逐步改进产品。 V1.0 是一个基础版本，它的核心功能是满足大家阅读、分享和检索轻氧资讯的诉求，在此版本里你可以： 随时浏览国内外知名互联网公司的交互、设计、前端以及 APP 等资讯动态信息 一键分享资讯至微信好友/朋友圈 搜索资讯，在 10000+ 资讯中找到你最感兴趣的内容 根据大数据将资讯标签化，点击标签即可找到更多相似的文章 接收由编辑挑选出精华文章和热点资讯推送 功能自然是没有 iOS 版本丰富，我们后续会继续给它填充血肉。我们计划在 V1.1 版本中加入账户体系，在 V1.2 加入评论等简单社交功能。 此外，鉴于 RN 的局限性，相对于iOS版本我们舍弃了很多的交互动效，也因此让整个安卓版的 APP 显得更简单直接，这未尝不是一件好事。 聊聊 React Native还记得去年底我们说要用 Weex 实现安卓版本，但不好意思那只是一个漂亮的假动作 XD。经过一番调研之后，我们发现 Weex 并不适合拿来写一个独立的 APP 产品。主要来说，它有以下几点缺陷： Weex 没有完整的路由组件 目前版本还没有稳定下来，官方某些组件存在不刷新的问题 第三方插件远不如 RN 的丰富 既然如此，那市面上就只有 React Native 了。虽说《某某公司在 React Native 实践中踩过的坑》的文章也看了不少，但我们还是毅然决断地随了大流。 果不其然，在踩进了坑之后，我们在开发中也发现了 RN 的一些缺陷： ListView 并没有实现复用机制，会带来额外的性能开销 WebView 没有 onScroll 回调，需要通过消息通知方式获取滚动的偏移量 RN 的升级和降级需要小心翼翼，一不小心就碰上了大麻烦 RN 的某些动画存在掉帧的情况，特别是数据量大的情况下 当然没有技术是完美的。抛开这些缺陷来说，RN 在效率上所带来的巨大提升，还是让人十分吃惊的。相对于 iOS 原生开发来说，用上 RN 后，我们再也不必为了调样式，而去上一次厕所（等待 build 完成…）。 不仅仅是开发上带来的便利。在 APP 上线之后，如果发现有什么 bug，我们也可以利用一些热更新机制，实现静默更新。 总的来说，RN 是一个很高效而且性能不错的框架，值得你去深入尝试。 下载体验很高兴安卓 V1.0 版本已经上架了，如果你有兴趣，欢迎点击这里前往应用宝下载试用。目前应用内还没整合反馈渠道，如果你有任何的想法，欢迎在文末留言，或者给我们来信，我们会回复每一封邮件。邮箱是 aotu#jd.com(# 改为 @)。 关于也许你是轻氧的潜在用户，所以还是在文末唠叨下 轻氧 是什么。 轻氧 是 凹凸实验室 出品的一款互联网专业资讯 APP，它囊括了众多知名互联网公司、团队及网站的资讯，让你能一口气把业界最优质的专业资讯文章读完，只要你这口气够长。 轻氧 精心选出了一些知名的 UED 和互联网站点，基于其简易信息聚合协议（RSS），将优质的互联网内容包装和分发，聚集到一个平台。 轻氧 搬运但不盗窃，如果你喜欢，你仍然可以把「轻氧」当成是一款RSS订阅器，尽管我们不止于订阅辣么简单，后续我们APP做开源分享的时候再做深入介绍。 经过半年时间的耕耘，轻氧目前已有超过 11000 篇资讯，来自于 40+ 资讯来源： 未来，我们还将在保证高质量文章的基础上，聚合更多的来源。","pubDate":"Fri, 03 Mar 2017 08:45:36 GMT","guid":"https://aotu.io/notes/2017/03/03/liteo2-android/","category":"移动开发"},{"title":"移动端真机调试指南","link":"https://aotu.io/notes/2017/02/24/Mobile-debug/","description":"导语：随着移动设备的普及以及微信庞大的用户量，移动端的需求也随之爆发式增长，平时我们使用 Chrome 进行手机模拟页面开发，但模拟终究是模拟，不可避免的还是需要真机调试，下面就来讲讲几种调试方案，希望能对你有所帮助。 系统自带调试功能iOS 系统运行环境要求 Mac + Safari 浏览器 iPhone（iOS 6 +） + Safari 浏览器 调试步骤 1、使用 Lightning 数据线将 iPhone 与 Mac 相连 2、iPhone 开启 Web 检查器（设置 -&gt; Safari -&gt; 高级 -&gt; 开启 Web 检查器） 3、iPhone 使用 Safari 浏览器打开要调试的页面 4、Mac 打开 Safari 浏览器调试（菜单栏 —&gt; 开发 -&gt; iPhone 设备名 -&gt; 选择调试页面） 如果你的菜单栏没有“开发”选项，可以到左上角 Safari -&gt; 偏好设置 -&gt; 高级 -&gt; 在菜单栏中显示“开发”菜单。 5、在弹出的 Safari Developer Tools 中调试 经过如上步骤就可在 Mac 端调试 iPhone 上 Safari 运行的页面了，但对于 WebView 页面就不适用了，另外 Windows 系统不适用此方案。 当前测试环境： Safari 版本 10.0.2 iPhone 7（iOS 10.1.1） 没有 iPhone 设备可以在 App Store 安装 Xcode 使用其内置的 iOS 模拟器，安装完成后通过以下两种方式开启： 右键 Xcode 图标 -&gt; Open Developer Tool -&gt; Simulator 右键 Finder 图标 -&gt; 前往文件夹 -&gt; /应用程序/Xcode.app/Contents/Developer/Applications/ -&gt; 运行 Simulator.app 运行 iOS 模拟器后，在模拟器中打开调试页面，再通过 Mac Safari 开发功能就可以调试到。 如果我需要调试更低版本的 iOS 怎么办？实际使用的 iPhone 不可能去降版本，不必担心，Simulator 有。 点击左上角 Xcode -&gt; Preferences -&gt; Downloads 就可以看到提供了如下版本： Android 系统运行环境要求 Chrome 版本 &gt;= 32 Android 版本 4.0 + 调试步骤 1、使用 USB 数据线将手机与电脑相连 2、手机进入开发者模式，勾选 USB 调试，并允许调试 如何开启 USB 调试： 索尼 Z5：设置 -&gt; 关于关机 -&gt; 多次点击软件版本开启 -&gt; 返回上一级 -&gt; 开发者选项 -&gt; USB 调试 魅蓝 Note：设置 -&gt; 辅助功能 -&gt; 开发者选项 -&gt; USB 调试 不同 Android 设备进入开发者模式的方式有稍稍不同，瞎捣鼓一下即可开启。 3、电脑打开 Chrome 浏览器，在地址栏输入：chrome://inspect/#devices 并勾选 Discover USB devices 选项 4、手机允许远程调试，并访问调试页面 官方的教程是想让你使用手机 Chrome 开启调试页面的，但实际需求更多的是调试一些 WebView 页面，在官方的 Remote Debugging WebViews 有说明是可以调试 WebView 页面的，Android 版本需要在 4.4 以上，并且 APP 需要有配置相应的启动调试代码。 WebView debugging must be enabled from within your application. To enable WebView debugging, call the static method setWebContentsDebuggingEnabled on the WebView class. 必须在 APP 内启动 WebView 调试。要启动 WebView 调试，需要调用 WebView 类上的静态方法 setWebContentsDebuggingEnabled。 123if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; WebView.setWebContentsDebuggingEnabled(true);&#125; This setting applies to all of the application’s WebViews. 此设置适用于所有 APP 的 WebView。 Tip: WebView debugging is not affected by the state of the debuggable flag in the application’s manifest. If you want to enable WebView debugging only when debuggable is true, test the flag at runtime. 提示：WebView 是否可调试状态不受 mainfest 标志变量 debuggable 的影响，如果你想在 debuggable 为 true 的时候启动 WebView 调试，请使用以下代码： 12345if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; if (0 != (getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE)) &#123; WebView.setWebContentsDebuggingEnabled(true); &#125;&#125; 5、电脑点击 inspect 按钮 如果你出现无法识别到设备的情况，建议尝试以下几种方法： 使用原装数据线，不要使用山寨数据线或一线多头的数据线 重新插拔 USB 数据线，让手机处于充电状态 关闭电脑相关的应用助手 重启手机 Windows 系统下自动安装驱动失败，到 Android Studio 手动下载 注意：使用 Chrome Inspect 查看页面时，Chrome 需要从 https://chrome-devtools-frontend.appspot.com 加载资源，如果你得到的调试界面是一片空白，那你可能需要科学上网。 6、进入调试界面 当前测试环境： Chrome 版本 55.0.2883.95 索尼 Z5（Android 5.1.1） 魅蓝 Note（Android 5.1） 三星 Galaxy S7（Android 6.0.1） 这里顺带提一下 TBS Studio 调试工具，它在 Chrome DevTools 调试功能的基础上进行了一些功能扩展，特性如下： 1.3 TBS Studio 功能特性 1）自动检测手机与 PC 的连接；2）自动检测网页是否可进行 Inspect 调试；3）自动引导开发者打开 Inspector 调试开关；4）一键开启 Inspector 调试，无需打开浏览器输入 URL，方便快捷；5）扩展 X5 内核独有 Inspect 选项，方便页面分析和优化；6）真机远程 Inspector 调试。 详细介绍和使用步骤可到开发者论坛查看，部分 Android 机型通过 USB 可能依旧无法识别到设备，可使用后面会讲到的其他方案。 关于 Android 虚拟机也是有的，这里推荐使用 Genymotion 软件，使用 Genymotion 前需要安装 VirtuaBox，并且注册登陆后才能显示所有的虚拟设备。 使用代理工具调试开发环境页面对于需要配 Hosts 才能访问的开发环境页面，手机在默认情况下是没有权限修改 Hosts 文件的，除非是 iOS 设备越狱后和 Android 设备 root 后，所以一般情况下手机是无法访问开发环境页面，这时需要使用到 Mac 系统的 Charles 代理工具，Windows 系统可使用 Fiddler 代理工具。 实现思路 Mac 作为代理服务器 手机通过 HTTP 代理连接到 Mac 电脑 手机上的请求都经过代理服务器 通过给 Mac 配 Hosts 实现目的 调试步骤 1、查看电脑 IP（菜单 -&gt; Help -&gt; Local IP Addresses） 2、查看端口（菜单 -&gt; Settings -&gt; Proxy Settings -&gt; Proxies） 默认端口为：8888，勾选 Enable transparent HTTP proxying 3、将 IP、端口号填入手机 HTTP 代理 iOS 系统：设置 -&gt; 无线局域网 -&gt; 点击叹号 -&gt; HTTP 代理 -&gt; 手动 Android 系统：设置 -&gt; 长按当前网络 -&gt; 修改网络 -&gt; 高级选项 -&gt; 手动 4、Charles 允许授权 每次有新设备首次连接都会提示是否授权，可以通过 Proxy -&gt; Access Control Settings 配置以下参数 0.0.0.0/0 来关闭。 5、使用 SwitchHosts! 软件给 Mac 电脑配 Hosts 6、手机访问开发环境页面 到这一步手机就可以访问到开发环境下的页面了，再结合前面所讲的方案来调试页面。 7、Charles 的调试功能 7.1 网络映射修改文件 除了结合前面的方案调试，可以使用 Map Local 网络映射功能来实现对文件的修改，在菜单 -&gt; Proxy -&gt; Start Recording 开启抓包后访问页面，找到抓取到的样式文件，点击右键 Map Local，在 Local path 中设置本地映射文件的路径，修改后刷新页面可以看到效果。 7.2 模拟网络速度 菜单 -&gt; Proxy -&gt; Throttle Settings -&gt; 勾选 Enable Throttling，在 Throttling preset 中可以选择需要模拟的网络速度。 7.3 抓取 HTTPS 请求 默认情况下，Charles 无法抓取到 HTTPS 的请求，解决步骤如下： Mac 端安装证书：菜单 -&gt; Help -&gt; SSL Proxying -&gt; Install Charles Root Certificate 然后导出 Charles SSL 证书安装到手机，菜单 -&gt; Help -&gt; SSL Proxying -&gt; Save Charles Root Certificate Android 设备导出的 Charles SSL 证书存储到手机中并安装。 iOS 设备用 Safari 打开 http://www.charlesproxy.com/getssl/ 页面，下载 Charles SSL 证书并安装。 证书安装完成后，还需要给 Charles SSL 代理配置域名和端口号，菜单 -&gt; Proxy -&gt; SSL Proxying Settings 勾选 Enable SSL Proxying 点击 Add 填入域名和端口号，经过以上步骤就可以抓取到 HTTPS 的请求了。 7.4 断点调试请求和响应内容 开启 Charles 断点 Proxy -&gt; Breakpoints Settings -&gt; Enable Breakpoints点击 Add 可设置断点条件或者单独对需要的文件右键 Breakpoints 设置断点。 访问页面后，即可编辑请求和响应的内容，点击 Execute 按钮完成。 Weinre 调试工具Weinre 是一款较老的远程调试工具，功能与 Chrome DevTools 相似，需要在页面中插入一段 JS 脚本来实时调试页面 DOM 结构、样式、JS 等，另外它使用的是代理的方式，所以兼容性很好，无论是新老设备系统通吃，但对于样式调试不友善，缺少断点调试及 Profiles 等常用功能。 调试步骤： 1、安装 Weinre 使用 NPM 全局安装 Weinre 1$ sudo npm -g install weinre 2、启动 Weinre 监听服务 12$ ipconfig getifaddr en0 // 查看本机 IP$ weinre --boundHost 10.14.217.14 --httpPort 8090 --boundHost 后填入你本机 IP 地址，--httpPort 后填入端口号，默认为 8080 3、进入 Weinre 管理页面 使用 Chrome 浏览器访问 http://10.14.217.14:8090，在管理页面你可以看到使用相关的说明，有进入客户端调试界面的地址、使用的文档、DEMO 页面等等，说明中要求将一段 JS 脚本 &lt;script src=&quot;http://10.14.217.14:8090/target/target-script-min.js#anonymous&quot;&gt;&lt;/script&gt; 插入到需要调试的页面中，插入代码后手机访问调试页面。 4、进入客户端调试界面 点击 debug client user interface：http://10.14.217.14:8090/client/#anonymous 的链接。 5、JS 脚本注入 手动加入 JS 脚本不优雅，这里可以结合我们前面提到的 Charles 代理工具实现动态 HTTP Script 注入。 打开菜单 -&gt; Rewrite -&gt; 勾选 Enable Rewrite 输入 Rewrite 的名字并且在 Rules 一项添加匹配的规则，Location 一项是用于指定的域名和端口添加规则用的，这里我们不填默认匹配所有请求。 Type 允许对需要匹配的请求进行 Rewrite，一共提供了 11 种： Add Header Modify Header Remove Header Host Path URL Add Query Param Modify Query Param Remove Query Param Response Status Body 这里我们需要使用到的是 Body，它的作用是对请求或响应内容进行匹配替换，按照下图的配置，通过将匹配到的响应内容 &lt;/body&gt; 标签替换成需要插入到页面中的 JS 脚本，从而实现动态插入。 另外，也有基于 Weinre 进行功能扩展的工具，比如早期版本的 微信 Web 开发者工具 v0.7.0 和 spy-debugger，都在 Weinre 的基础上简化了要给每个调试页面添加 JS 脚本的步骤，spy-debugger 还增加了对 HTTPS 的支持。 感谢你的阅读，如果你还有其他更为实用的调试方案，欢迎下方留言交流。 参考资料 Safari Web Inspector Guide Get Started with Remote Debugging Android Devices Remote Debugging WebViews weinre - Running Charles Web Debugging Proxy wuchangming/spy-debugger TBS 开发调试利器 —— TBS Studio - QQ 浏览器移动产品论坛 微信 web 开发者工具","pubDate":"Fri, 24 Feb 2017 06:45:36 GMT","guid":"https://aotu.io/notes/2017/02/24/Mobile-debug/","category":"Web开发"},{"title":"“等一下，我碰！”——常见的2D碰撞检测","link":"https://aotu.io/notes/2017/02/16/2d-collision-detection/","description":"“碰乜鬼嘢啊，碰走晒我滴靓牌”。想到“碰”就自然联想到了“麻将”这一伟大发明。当然除了“碰”，洗牌的时候也充满了各种『碰撞』。 好了，不废话。直入主题——碰撞检测。 在 2D 环境下，常见的碰撞检测方法如下： 外接图形判别法 轴对称包围盒（Axis-Aligned Bounding Box），即无旋转矩形。 圆形碰撞 光线投射法 分离轴定理 其他 地图格子划分 像素检测 下文将由易到难的顺序介绍上述各种碰撞检测方法：外接图形判别法 &gt; 其他 &gt; 光线投射法 &gt; 分离轴定理。 另外，有一些场景只要我们约定好限定条件，也能实现我们想要的碰撞，如下面的碰壁反弹： See the Pen Boundary collision detection by Jc (@JChehe) on CodePen. 当球碰到边框就反弹(如x/y轴方向速度取反)。 12if(ball.left &lt; 0 || ball.right &gt; rect.width) ball.velocityX = -ball.velocityXif(ball.top &lt; 0 || ball.bottom &gt; rect.height) ball.velocityY = -ball.velocityY 再例如当一个人走到 100px 位置时不进行跳跃，就会碰到石头等等。 因此，某些场景只需通过设定到适当的参数即可。 外接图形判别法轴对称包围盒（Axis-Aligned Bounding Box）概念：判断任意两个（无旋转）矩形的任意一边是否无间距，从而判断是否碰撞。 算法： 1234rect1.x &lt; rect2.x + rect2.width &amp;&amp;rect1.x + rect1.width &gt; rect2.x &amp;&amp;rect1.y &lt; rect2.y + rect2.height &amp;&amp;rect1.height + rect1.y &gt; rect2.y 两矩形间碰撞的各种情况： 在线运行示例（先点击运行示例以获取焦点，下同）： See the Pen AxisAlignedBoundingBox collision detection by Jc (@JChehe) on CodePen. 缺点： 相对局限：两物体必须是矩形，且均不允许旋转（即关于水平和垂直方向上对称）。 对于包含着图案（非填满整个矩形）的矩形进行碰撞检测，可能存在精度不足的问题。 物体运动速度过快时，可能会在相邻两动画帧之间快速穿越，导致忽略了本应碰撞的事件发生。 适用案例： （类）矩形物体间的碰撞。 圆形碰撞（Circle Collision）概念：通过判断任意两个圆形的圆心距离是否小于两圆半径之和，若小于则为碰撞。 两点之间的距离由以下公式可得： 判断两圆心距离是否小于两半径之和： 123Math.sqrt(Math.pow(circleA.x - circleB.x, 2) + Math.pow(circleA.y - circleB.y, 2)) &lt; circleA.radius + circleB.radius 图例： 在线运行示例： See the Pen EZrorG by Jc (@JChehe) on CodePen. 缺点： 与『轴对称包围盒』类似 适用案例： （类）圆形的物体，如各种球类碰撞。 其他地图格子划分概念：将地图（场景）划分为一个个格子。地图中参与检测的对象都存储着自身所在格子的坐标，那么你即可以认为两个物体在相邻格子时为碰撞，又或者两个物体在同一格才为碰撞。另外，采用此方式的前提是：地图中所有可能参与碰撞的物体都要是格子单元的大小或者是其整数倍。 蓝色X 为障碍物： 实现方法： 12345678910111213// 通过特定标识指定（非）可行区域map = [ [0, 0, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 0, 0, 1, 0, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 0, 0, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 1, 0, 0]],// 设定角色的初始位置player = &#123;left: 2, top: 2&#125;// 移动前（后）判断角色的下一步的动作（如不能前行）... 在线运行示例： See the Pen map cell collision detection by Jc (@JChehe) on CodePen. 缺点： 适用场景局限。 适用案例： 推箱子、踩地雷等 像素检测概念：以像素级别检测物体之间是否存在重叠，从而判断是否碰撞。 实现方法有多种，下面列举在 Canvas 中的两种实现方式： 如下述的案例中，通过将两个物体在 offscreen canvas 中判断同一位置（坐标）下是否同时存在非透明的像素。 利用 canvas 的 globalCompositeOperation = &#39;destination-in&#39; 属性。该属性会让两者的重叠部分会被保留，其余区域都变成透明。因此，若存在非透明像素，则为碰撞。 注意，当待检测碰撞物体为两个时，第一种方法需要两个 offscreen canvas，而第二种只需一个。 offscreen canvas：与之相关的是 offscreen rendering。正如其名，它会在某个地方进行渲染，但不是屏幕。“某个地方”其实是内存。渲染到内存比渲染到屏幕更快。—— Offscreen Rendering 当然，我们这里并不是利用 offscreen render 的性能优势，而是利用 offscreen canvas 保存独立物体的像素。换句话说：onscreen canvas 只是起展示作用，碰撞检测是在 offscreen canvas 中进行。 另外，由于需要逐像素检测，若对整个 Canvas 内所有像素都进行此操作，无疑会浪费很多资源。因此，我们可以先通过运算得到两者相交区域，然后只对该区域内的像素进行检测即可。 图例： 下面示例展示了第一种实现方式： See the Pen pixel collision detection by Jc (@JChehe) on CodePen. 缺点： 因为需要检查每一像素来判定是否碰撞，性能要求比较高。 适用案例： 需要以像素级别检测物体是否碰撞。 光线投射法（Ray Casting）概念：通过检测两个物体的速度矢量是否存在交点，且该交点满足一定条件。 对于下述抛小球入桶的案例：画一条与物体的速度向量相重合的线(#1)，然后再从另一个待检测物体出发，连线到前一个物体，绘制第二条线(#2)，根据两条线的交点位置来判定是否发生碰撞。 抛球进桶图例： 在小球飞行的过程中，需要不断计算两直线的交点。 当满足以下两个条件时，那么应用程序就可以判定小球已落入桶中： 两直线交点在桶口的左右边沿间 小球位于第二条线（#2）下方 在线运行示例： See the Pen ray casting collision detection by Jc (@JChehe) on CodePen. 优点： 适合运动速度快的物体 缺点： 适用范围相对局限。 适用案例： 抛球运动进桶。 分离轴定理（Separating Axis Theorem）概念：通过判断任意两个 凸多边形 在任意角度下的投影是否均存在重叠，来判断是否发生碰撞。若在某一角度光源下，两物体的投影存在间隙，则为不碰撞，否则为发生碰撞。 图例： 在程序中，遍历所有角度是不现实的。那如何确定 投影轴 呢？其实投影轴的数量与多边形的边数相等即可。 以较高抽象层次判断两个凸多边形是否碰撞： 123456789101112131415161718function polygonsCollide(polygon1, polygon2) &#123; var axes, projection1, projection2 // 根据多边形获取所有投影轴 axes = polygon1.getAxes() axes.push(polygon2.getAxes()) // 遍历所有投影轴，获取多边形在每条投影轴上的投影 for(each axis in axes) &#123; projection1 = polygon1.project(axis) projection2 = polygon2.project(axis) // 判断投影轴上的投影是否存在重叠，若检测到存在间隙则立刻退出判断，消除不必要的运算。 if(!projection1.overlaps(projection2)) return false &#125; return true&#125; 上述代码有几个需要解决的地方： 如何确定多边形的各个投影轴 如何将多边形投射到某条投影轴上 如何检测两段投影是否发生重叠 投影轴如下图所示，我们使用一条从 p1 指向 p2 的向量来表示多边形的某条边，我们称之为边缘向量。在分离轴定理中，还需要确定一条垂直于边缘向量的法向量，我们称之为“边缘法向量”。 投影轴平行于边缘法向量。投影轴的位置不限，因为其长度是无限的，故而多边形在该轴上的投影是一样的。该轴的方向才是关键的。 12345678// 以原点(0,0)为始，顶点为末。最后通过向量减法得到 边缘向量。var v1 = new Vector(p1.x, p1.y) v2 = new Vector(p2.x, p2.y)// 首先得到边缘向量，然后再通过边缘向量获得相应边缘法向量（单位向量）。// 两向量相减得到边缘向量 p2p1（注：上面应该有个右箭头，以表示向量）。// 设向量 p2p1 为(A,B)，那么其法向量通过 x1x2+y1y2 = 0 可得：(-B,A) 或 (B,-A)。 axis = v1.edge(v2).normal() 以下是向量对象的部分实现，具体可看源码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var Vector = function(x, y) &#123; this.x = x this.y = y&#125;Vector.prototype = &#123; // 获取向量大小（即向量的模），即两点间距离 getMagnitude: function() &#123; return Math.sqrt(Math.pow(this.x, 2), Math.pow(this.y, 2)) &#125;, // 点积的几何意义之一是：一个向量在平行于另一个向量方向上的投影的数值乘积。 // 后续将会用其计算出投影的长度 dotProduct: function(vector) &#123; return this.x * vector.x + this.y + vector.y &#125;, // 向量相减 得到边 subtarct: function(vector) &#123; var v = new Vector() v.x = this.x - vector.x v.y = this.y - vector.y return v &#125;, edge: function(vector) &#123; return this.substract(vector) &#125;, // 获取当前向量的法向量（垂直） perpendicular: function() &#123; var v = new Vector() v.x = this.y v.y = 0 - this.x return v &#125;, // 获取单位向量（即向量大小为1，用于表示向量方向），一个非零向量除以它的模即可得到单位向量 normalize: function() &#123; var v = new Vector(0, 0) m = this.getMagnitude() if(m !== 0) &#123; v.x = this.x / m v.y = this.y /m &#125; return v &#125;, // 获取边缘法向量的单位向量，即投影轴 normal: function() &#123; var p = this.perpendicular() return p .normalize() &#125;&#125; 向量相减 更多关于向量的知识可通过其它渠道学习。 投影投影的大小：通过将一个多边形上的每个顶点与原点(0,0)组成的向量，投影在某一投影轴上，然后保留该多边形在该投影轴上所有投影中的最大值和最小值，这样即可表示一个多边形在某投影轴上的投影了。 判断两多边形的投影是否重合：projection1.max &gt; projection2.min &amp;&amp; project2.max &gt; projection.min 为了易于理解，示例图将坐标轴原点(0,0)放置于三角形边1投影轴的适当位置。 由上述可得投影对象： 123456789101112// 用最大和最小值表示某一凸多边形在某一投影轴上的投影位置var Projection = function (min, max) &#123; this.min this.max&#125;projection.prototype = &#123; // 判断两投影是否重叠 overlaps: function(projection) &#123; return this.max &gt; projection.min &amp;&amp; projection.max &gt; this.min &#125;&#125; 如何得到向量在投影轴上的长度？向量的点积的其中一个几何含义是：一个向量在平行于另一个向量方向上的投影的数值乘积。由于投影轴是单位向量（长度为1），投影的长度为 x1 * x2 + y1 * y2 123456789101112// 根据多边形的每个定点，得到投影的最大和最小值，以表示投影。function project = function (axis) &#123; var scalars = [], v = new Vector() this.points.forEach(function (point) &#123; v.x = point.x v.y = point.y scalars.push(v.dotProduct(axis)) &#125;) return new Projection(Math.min.apply(Math, scalars), Math.max,apply(Math, scalars))&#125; 圆形与多边形之间的碰撞检测由于圆形可近似地看成一个有无数条边的正多边形，而我们不可能按照这些边一一进行投影与测试。我们只需将圆形投射到一条投影轴上即可，这条轴就是圆心与多边形顶点中最近的一点的连线，如图所示： 因此，该投影轴和多边形自身的投影轴就组成了一组待检测的投影轴了。 而对于圆形与圆形之间的碰撞检测依然是最初的两圆心距离是否小于两半径之和。 分离轴定理的整体代码实现，可查看以下案例： See the Pen SeparatingAxisTheorem by Jc (@JChehe) on CodePen. 优点： 精确 缺点： 不适用于凹多边形 适用案例： 任意凸多边形和圆形。 更多关于分离轴定理的资料： Separating Axis Theorem (SAT) explanation Collision detection and response Collision detection Using the Separating Axis Theorem SAT (Separating Axis Theorem) Separation of Axis Theorem (SAT) for Collision Detection 延伸：最小平移向量（MIT）通常来说，如果碰撞之后，相撞的双方依然存在，那么就需要将两者分开。分开之后，可以使原来相撞的两物体彼此弹开，也可以让他们黏在一起，还可以根据具体需要来实现其他行为。不过首先要做的是，还是将两者分开，这就需要用到最小平移向量（Minimum Translation Vector, MIT）。 碰撞性能优化若每个周期都需要对全部物体进行两两判断，会造成浪费（因为有些物体分布在不同区域，根本不会发生碰撞）。所以，大部分游戏都会将碰撞分为两个阶段：粗略和精细（broad/narrow）。 粗略阶段（Broad Phase）Broad phase 能为你提供有可能碰撞的实体列表。这可通过一些特殊的数据结构实现，它们能为你提供信息：实体存在哪里和哪些实体在其周围。这些数据结构可以是：四叉树（Quad Trees）、R树（R-Trees）或空间哈希映射（Spatial Hashmap）等。 读者若感兴趣，可以自行查阅相关信息。 精细阶段（Narrow Phase）当你有了较小的实体列表，你可以利用精细阶段的算法（如上述讲述的碰撞算法）得到一个确切的答案（是否发生碰撞）。 最后无论你碰不碰，我都会自摸🀄️✌️。 完！ 参考资料 MDN：2D collision detection 《HTML5 Canvas 核心技术：图形、动画与游戏开发》","pubDate":"Thu, 16 Feb 2017 10:00:00 GMT","guid":"https://aotu.io/notes/2017/02/16/2d-collision-detection/","category":"Web开发"},{"title":"探讨判断横竖屏的最佳实现","link":"https://aotu.io/notes/2017/01/31/detect-orientation/","description":"在移动端，判断横竖屏的场景并不少见，比如根据横竖屏以不同的样式来适配，抑或是提醒用户切换为竖屏以保持良好的用户体验。判断横竖屏的实现方法多种多样，本文就此来探讨下目前有哪些实现方法以及其中的优缺点。 CSS Media Queries通过媒体查询的方式，我们可以通过以下方法来实现根据横竖屏不同的情况来适配样式： 1.内联样式1234567@media screen and (orientation:portrait) &#123; //竖屏&#125;@media screen and (orientation:landscape) &#123; //横屏&#125; 2.外联样式12345&lt;!-- 竖屏 --&gt;&lt;link rel=\"stylesheet\" media=\"all and (orientation:portrait)\" href=\"...\" /&gt;&lt;!-- 横屏 --&gt;&lt;link rel=\"stylesheet\" media=\"all and (orientation:landscape)\" href=\"...\" /&gt; window.matchMedia()除此之外，CSS Object Model（CSSOM）Views 规范增加了对 JavaScript 操作 CSS Media Queries 的原生支持，它在 window 对象下增加了 matchMedia() 方法，让我们能够通过脚本的方式来实现媒体查询。 window.matchMedia() 方法接受一个 Media Queries 语句的字符串作为参数，返回一个 MediaQueryList 对象。该对象有 media 和 matches 两个属性： media：返回所查询的 Media Queries 语句字符串 matches：返回一个布尔值，表示当前环境是否匹配查询语句 同时，它还包含了两个方法，用来监听事件： addListener(callback)：绑定回调 callback 函数 removeListener(callback)：注销回调 callback 函数 那么，通过 window.matchMedia() 的方法，我们可以这样判断横竖屏： 12345678910var mql = window.matchMedia(\"(orientation: portrait)\");function onMatchMeidaChange(mql)&#123; if(mql.matches) &#123; // 竖屏 &#125;else &#123; // 横屏 &#125;&#125;onMatchMeidaChange(mql);mql.addListener(onMatchMeidaChange); 通过Can I Use - matchMeida可以知道，该API在移动端得到良好的支持，并无兼容性问题。 window.innerHeight/window.innerWidth The ‘orientation’ media feature is ‘portrait’ when the value of the ‘height’ media feature is greater than or equal to the value of the ‘width’ media feature. Otherwise ‘orientation’ is ‘landscape’.—— CSS/Mediaqueries/orientation 在 CSS Media Queries 中，Orientation 属性有两个值： portrait，指的是当 height 大于等于 width 的情况 landscape，指的是当 height 小于 width 的情况 所以，还有一种最为常见的方法是通过比较页面的宽高，当页面的高大于等于宽时则认为是竖屏，反之则为横屏。 123456789function detectOrient()&#123; if(window.innerHeight &gt;= window.innerWidth) &#123; // 竖屏 &#125;else &#123; // 横屏 &#125;&#125;detectOrient();window.addEventListener('resize',detectOrient); window.orientation在 iOS 平台以及大部分 Android 手机都有支持 window.orientation 这个属性，它返回一个与默认屏幕方向偏离的角度值： 0：代表此时是默认屏幕方向 90：代表顺时针偏离默认屏幕方向90度 -90：代表逆时针偏离默认屏幕方向90度 180：代表偏离默认屏幕方向180度 在 iOS 的开发者文档（iOS Developer Library - Handling Orientation Events）是这样明确定义的： 1234567891011121314151617switch(window.orientation) &#123; case 0: displayStr += \"Portrait\"; break; case -90: displayStr += \"Landscape (right, screen turned clockwise)\"; break; case 90: displayStr += \"Landscape (left, screen turned counterclockwise)\"; break; case 180: displayStr += \"Portrait (upside-down portrait)\"; break;&#125; 也就是如下图所示： （图来自William Malone - DETECT IOS DEVICE ORIENTATION WITH JAVASCRIPT） 在实际应用中，对于 iPhone 和大部分 Android 是没有180度的手机竖屏翻转的情况的，但是 iPad 是存在的。所以，简化下代码，我们可以绑定orientationchange事件来判断横竖屏： 123456789function detectOrient()&#123; if (Math.abs(window.orientation) === 90) &#123; // 横屏 &#125; else &#123; // 竖屏 &#125;&#125;detectOrient();window.addEventListener('orientationchange',detectOrient); 影响判断的问题所在1.对window.orientation属性值的不一致在 iOS 平台，对 window.orientation 属性值是无异议的，规范当中有明确规定每个值对应的情况。但是对于 Android 平台，就有不一致的特殊情况出现。 A misconception about window.orientation中作者 Matthew Gifford 就有提到部分 Android 机型(该文章中测试用的 Toshiba Thrive 机型)返回的情况是与期望情况是相反的；除此之外，在 StackOverflow 上也有反馈过这样的问题（例如，window.orientation returns different values in iOS and Android中提到的 Samsung Tab 2 机型）。 其实，Matthew Gifford 认为这并不是 BUG（笔者也认同），按照Compatibility Standard - 4.2 window.orientation API规范中的定义，0 值指的是 natural 、 default 的屏幕方向，所以如果生厂商对 natural 、 default 状态是用户应当手持设备方向为横屏，那么 0 值对应为 landscape 的横屏方向了。针对这种不一致情况的出现，对于追求完美的开发者来说，通过 window.orientation 的方法来判断横竖屏则变得有点不可靠的。 2.软键盘的弹出是否除了 window.orientation 的其它方法都是可靠的呢？然而，实际上是事与愿违的。在 Android 下，如果页面中出现软键盘弹出的情况（存在有 Input 的元素）时，页面有时会因为软键盘的弹出而导致页面回缩，即页面的宽度（竖屏时）或者高度（横屏时）被改变。无论是 CSS Media Queries 还是 window.matchMedia() 方法，还是根据 window.innerWidth 、window.innerHeight的页面宽高比对方法来实现的横竖屏判断方法，都会因此受到影响，出现判断失误的情况（ Samsung SCH-i699 机型，在竖屏时由于软键盘弹出导致页面高度小于宽度，被错误地判定为横屏）。所以，在这样的情况下，这几种方式也变得不可靠。 探讨最佳实现方式本着核心的原则——具体情况具体解决来讨论。 如果你没有遇上以上两个问题所在，恭喜你！上面所提到的方法都可以被应用，选择你最为喜欢的方法就好。 但是如果想要避免以上两个问题所在，有没有更好的办法呢？ 经过实际情况的研究，针对开发环境兼容的情况（ iOS 与 Android 下的微信内置浏览器与原生浏览器）来说，屏幕分辨率是不会改变的，那么我们可以尝试比对页面宽高和屏幕分辨率来判断横竖屏。 需要注意的是，微信内置浏览器页面宽度不包括顶栏部分的，而 Android 和 iOS 的原生浏览器都是带有底栏或顶栏兼有的，如下图所示。 （图为 iPhone 6s 下的微信内置浏览器与原生浏览器截图） 那么，我们可以确定为： 假如屏幕分辨率固定值为：screen.width 和 screen.height（需要注意，这里很重要的一点是：在移动端，屏幕翻转时，screen.width 和 screen.height 的值依然是不变的） 若获取 当前页面的宽（document.documentElement.clientWidth），等于屏幕分辨率的宽(screen.width)，则可认定当前属于竖屏。 （图为以 iPhone 6s 竖屏下的微信内置浏览器为例的截图） 若获取 当前页面的宽（document.documentElement.clientWidth），等于屏幕分辨率的高(screen.height)，则可认定当前属于横屏。 （图为以 iPhone 6s 横屏下的微信内置浏览器为例的截图） 如此，对应的代码为： 1234567891011121314151617181920212223242526272829function detectOrient() &#123; var storage = localStorage; var data = storage.getItem('J-recordOrientX'); var w = document.documentElement.clientWidth, h = document.documentElement.clientHeight; var _Width = 0, _Height = 0; if(!data) &#123; _Width = window.screen.width; _Height = window.screen.height; storage.setItem('J-recordOrientX',_Width + ',' + _Height); &#125;else &#123; var str = data.split(','); _Width = str[0]; _Height = str[1]; &#125; if(w == _Width) &#123; // 竖屏 return; &#125; if(w == _Height)&#123; // 横屏 return; &#125;&#125;detectOrient();window.addEventListener('resize',detectOrient); 以上是笔者拙劣的见解，如果你有更好的办法解决，欢迎来分享！ 今后的发展目前，W3C 引入Screen Orientation API，该标准能够帮助 Web 应用获得屏幕方向的状态，在状态改变时获得通知，并能够从应用程序中将屏幕状态锁定到特定状态。但截止目前，该标准仍在 W3C 草案阶段。在移动端，它在 Android 和 iOS 平台上仍未得到支持，仅仅在 Chrome for Android 39 版本及以上才得到实现，所以对目前的开发来说意义不大。只能期待它能够尽快通过并得到广泛支持，这样的检测屏幕方向的问题就能够得到规范化的解决。 参考文档 A misconception about window.orientation Trouble with web browser orientation Compatibility Standard - 4.2 window.orientation API","pubDate":"Tue, 31 Jan 2017 01:27:00 GMT","guid":"https://aotu.io/notes/2017/01/31/detect-orientation/","category":"Web开发"},{"title":"使用 Snap.svg 制作动画","link":"https://aotu.io/notes/2017/01/22/snapsvg/","description":"一、Snap.svg是什么从主要功能上说，Snap.svg.js 是一个操纵 SVG 节点/制作 SVG 动画的框架，简单点理解可以看下面文字： Snap.svg 是一个可以使你操纵 SVG 资源和 jQuery 操作 DOM 一样简单的类库 ——译自官网 拿 Snap.svg (下文简称 Snap ) 和 jQuery (下文简称 JQ ) 来做对比最合适不过，很可能作者也是参考了 JQ 的 API 设计，那么它们的相似程度有多高呢？请看下面的对比表： / context(上下文) 选择器 事件绑定 节点操作 属性操作 链式写法 Snap svg Snap.select(‘circle’) el.click(…)/el.touchend(…) after()/remove()/append() attr() svg.paper.circle(50,50,40).attr({fill:”#f00”}); JQ document jQuery(‘div’) el.click(…) after()/remove()/append() attr() elem.addClass(‘hide’).remove(); 在 JQ 中，可操作的最外层 DOM 边界是 document 。而在 Snap 的概念里，可操作的最外层的节点是 svg ，svg 节点的选择、事件绑定都需要在这个上下文里完成。 在上面的对比图可以看出很多 JQ 的影子，无论是选择器、事件绑定、节点操作等等，都是非常的类似 JQ ，有 JQ 基础的同学基本可以半天掌握 Snap 的全部 API。 二、Snap 的代码结构 笔者根据 Snap 的 API 制作了上面的图表，并且简单标注了注释方便大家理解，可以重点关注一下 Element 和 Paper 这两个类。 1. Element这个部分是节点操作相关的方法集，也是该类库最基础的部分。 1234// 选择节点var svg = Snap('#svg');svg.select('circle'); // 选择svg.select('.rect_01'); // 选择 12345// 事件绑定var svg = Snap('#svg');svg.select('circle').click(function() &#123; // do something&#125;); 更多方法请参考文后 API 资料。 2. Paper这部分是画图相关的方法集，这是几乎每个动画框架都有的部分，类似于createjs的Graphics。 SVG 有6种基本图形：矩形、圆形 、椭圆、线条、折线、多边形。还有另外一种：路径(path)，path 是最复杂的一种绘图方式，它可以绘制复杂的图形——当然6种基本图形也不在话下。而关于基本图像与 path 之间的转换，可以参考本站的另外一篇文章：聊聊 SVG 基本形状转换那些事。 Paper 方法集主要可以绘制6种基本图形（节点），以及文本（节点）、图片（节点）、渐变等。 1234567891011// 画一个圆var svg = Snap('#svg');svg.paper.circle(&#123; cx: 100, cy: 100, r: 50, fill: '#f00'&#125;);// 创建一张图片svg.paper.image('url.jpg', 0, 400, 300, 300); 3. Snap 工具方法Snap下有不少实用工具，比如 Snap.ajax、Snap.format模板、颜色格式转换和插件方法等。 123456// 扩展Snap，为其添加插件方法Snap.plugin(function (Snap, Element, Paper, global, Fragment) &#123; Snap.newmethod = function () &#123;&#125;; Element.prototype.newmethod = function () &#123;&#125;; Paper.prototype.newmethod = function () &#123;&#125;;&#125;); 三、用 Snap 制作动画1. 制作动画的方法Snap 的做动画主要有两种方式： 使用 Element 里的 animate 方法，Element.animate(attrs, duration, [easing], [callback]) 使用 Snap 的静态方法，Snap.animate(from, to, setter, duration, [easing], [callback])，这种方法更通用也更强大，指定开始结束值，setter里面可以放置多个节点的动画。 样例：演示Element.animate方法的使用。预览地址点此 12345678910111213141516// 动画样例1var svg = Snap('#svg');svg.select('circle').animate(&#123;r: 100&#125;, 1000, mina.easeout(), function() &#123; console.log('animation end');&#125;);// 动画样例2var svg = Snap('#svg');var circle = svg.select('circle');var rect = svg.select('rect');Snap.animate(0, 100, function(val) &#123; circle.attr(&#123;r: val&#125;); rect.attr(&#123;x: val&#125;);&#125;, 1000, mina.easeout(), function() &#123; console.log('animation end');&#125;); 2. 动画的属性在 Snap 中，可作为动画的属性有哪些呢？笔者大致分为了几类： 简单数值类，如坐标、宽高、opacity、大部分 Paper API 可配置的属性值，甚至滤镜相关的属性。如{x:100} -&gt; {x:200}, {width:0} -&gt; {width:100} path 相关动画，如d属性（变形动画）、描边动画、路径跟随动画 matrix 类，放大缩小、位移、旋转等，和 CSS 的 transform 类似 颜色类，颜色变换动画，如 fill、stroke 属性，如{fill:’#f00’} -&gt; {fill:’#f0f’} 样例：颜色变换动画，预览地址点此 123456// 动画样例，颜色变化动画var svg = Snap('#svg');var circle = svg.paper.circle(&#123;cx: 100, cy: 100, r: 50, fill: '#f00'&#125;);circle.animate(&#123;fill: '#00f'&#125;, 1000, mina.easeout(), function() &#123; console.log('animation end');&#125;); 四、path &amp; matrix 动画详解这个小节重点会讲上面第2小节提到的 path、matrix 相关动画方式，以及和 CSS 的 transform 动画的异同。 1. path 动画1). path 变形动画这种类型的动画非常强大。上文已提到基本图形和 path 是可以相互转换的，所以基本图形间的变形动画也是成立的。不仅如此，更复杂的 path 图形，比如波浪、房子、汽车、白云、小icon等，都是可以互相变形。 path 的d属性在 Snap 的解析规则里可以通过一系列的数学运算，动画中通过插值，达到最终态的d值，不过中间的插值计算我们无法干预。 123456789101112// 开始态var path = svg.paper.path(&#123;d: 'M0.500,65.500 C18.680,33.758 45.141,-6.797 72.500,2.500 C99.859,11.797 72.148,59.027 79.500,98.500 C86.852,137.973 117.668,128.914 138.500,59.500 C159.332,-9.914 246.500,59.500 246.500,59.500 C273.181,117.750 137.350,184.417 225.500,173.500 C351.137,157.940 155.369,160.617 162.500,86.500 C165.180,58.645 237.169,-2.418 283.500,2.500 C357.654,10.371 363.758,80.355 364.500,109.500',stroke:'#f00', fill: 'rgba(0,0,0,0)'&#125;);setTimeout(function() &#123; // 终止态：曲线变直 // path.animate(&#123;d: 'M1,100 L350,100'&#125;, 1000, mina.easeout(), function() &#123; // console.log('animation end'); // &#125;); // 终止态：心形 path.animate(&#123;d: 'M114.500,58.500 C106.230,58.751 23.907,-37.262 5.500,21.500 C-26.759,124.483 111.761,221.360 119.500,219.500 C154.464,211.096 201.234,149.580 220.500,104.500 C250.260,34.864 220.892,7.159 194.500,1.500 C160.455,-5.800 122.344,58.262 114.500,58.500 Z'&#125;, 1000, mina.easeout(), function() &#123; console.log('animation end'); &#125;);&#125;, 1000); 样例：曲线变直线，预览地址点此 样例：曲线变心形，预览地址点此 2). path 描边动画这种动画主要用的是 svg 的 stroke-dasharray、stroke-dashoffset 属性，这中动画方式在本站的另外一篇文章有详细介绍，这里不再赘述：三看 SVG Web 动效 样例：简单曲线描边动画12345678910111213var path = svg.paper.path(&#123;d: 'M0.500,65.500 C18.680,33.758 45.141,-6.797 72.500,2.500 C99.859,11.797 72.148,59.027 79.500,98.500 C86.852,137.973 117.668,128.914 138.500,59.500 C159.332,-9.914 246.500,59.500 246.500,59.500 C273.181,117.750 137.350,184.417 225.500,173.500 C351.137,157.940 155.369,160.617 162.500,86.500 C165.180,58.645 237.169,-2.418 283.500,2.500 C357.654,10.371 363.758,80.355 364.500,109.500', stroke:'#f00', fill: 'rgba(0,0,0,0)'&#125;);var length = Snap.path.getTotalLength(path);path.attr(&#123; 'stroke-dashoffset': length, 'stroke-dasharray': length // 用Snap的API计算复杂的path长度&#125;);Snap.animate(length, 0, function(val) &#123; path.attr(&#123; 'stroke-dashoffset': val &#125;);&#125;, 1000, mina.easeout(), function() &#123; console.log('animation end');&#125;); 或者用CSS实现：12345678@keyframes demo4 &#123; 100% &#123; stroke-dashoffset: 0 &#125;&#125;.demo4 &#123; animation: demo4 1s ease-out infinite both;&#125; 样例：花纹描边。这是codepen上一个复杂的例子——复杂花纹的描边动画，预览地址点此： 3). path 路径跟随动画这种动画是指一个 svg 节点（基本图形、文本、图片等）沿着轨迹移动的动画，主要适用于模拟交通工具航行轨迹、粒子散开轨迹等。 这种动画的关键之处在于要知道 path 的长度与坐标之间的对应关系，Snap 提供了可供获取path的长度以及根据长度获取位置坐标的 API。结合上面的 Snap.animate 方法，路径跟随动画的制作会变得非常简单。 样例：跟随曲线运动的小飞机，预览地址点此： 12345678910var length = Snap.path.getTotalLength(path); // 获取path的长度Snap.animate(0, length, function(val) &#123; var point = Snap.path.getPointAtLength(path, val); // 根据path长度变化获取坐标 var m = new Snap.Matrix(); m.translate(point.x, point.y); m.rotate(point.alpha-90); // 使飞机总是朝着曲线方向。point.alpha：点的切线和水平线形成的夹角 plane.transform(m);&#125;, 30000, mina.easeout(), function() &#123; console.log('animation end');&#125;); 样例：双12开场动画，这是笔者去年双12做的一个路径跟随动画效果，预览地址点此： 另外，用新的 CSS 属性 motion-path 也可以实现类似效果，但目前支持程度堪忧，只有 PC 的 chrome 以及 Opera、最新的X5内核手机浏览器 支持情况较好。 12345678910111213@keyframes demo5 &#123; 0% &#123; motion-offset: 0; &#125; 100% &#123; motion-offset: 100%; &#125;&#125;.demo5 &#123; motion-path: path(\"M221.712,180.442C237.176,177.728,279.348,178.094,261,152c-18.742-26.654-48.543-28.207-63-22-14.981,6.431-34.763,6.357-34,40s66.09,74.162,88,68,60.358-23.742,67-49,14.211-59.957-27-81S163.688,88.664,153,98c-7.828,6.838-32.045,22.952-32,64,0.039,35.491,7.878,62.872,14,78s52.737,39.557,73,41,58.638,16.552,105-7c44.249-22.478,75.073-94.409,55-164C349.768,46.792,217.142,54.519,200,55S104.613,66.128,78,111c-16.922,28.532-16.5,96.616,1,134,14.482,30.932,51.88,58.52,68,64,39.988,13.593,100.081,21.615,129,17\"); motion-rotation: auto 90deg; // 使飞机方向始终朝着曲线 animation: demo5 10s linear infinite both;&#125; 预览地址点此（请在最新版 chrome、Opera 或最新的X5内核手机浏览器查看） 2. matrix动画Snap 的 matrix 动画包含各位熟悉的 translate/scale/rotate/skew 动画，原理和 CSS 的 transform 也几乎一致。 1) matrix简单位移动画，预览地址点此： 12345678910111213// 简单位移动画var rect = svg.paper.rect(&#123;x: 100, y: 100, width: 50, height: 30, fill: '#f00'&#125;);var anim = function() &#123; Snap.animate(0, 150, function(val) &#123; var m = new Snap.Matrix(); m.translate(val, 0); // translate位移API rect.transform(m); // 在rect节点应用matrix &#125;, 1000, mina.easeout(), function() &#123; console.log('animation end'); setTimeout(anim, 300); &#125;);&#125;anim(); 2) matrix位移、旋转复合动画，预览地址点此： 12345678910111213141516171819202122232425// 位移、旋转复合动画var rect = svg.paper.rect(&#123;x: 10, y: 100, width: 50, height: 30, fill: '#f00'&#125;);var g = svg.paper.group(rect); // 创建了一个分组节点g作为位移动画节点var anim_rotate = function() &#123; // 节点旋转部分 Snap.animate(0, 250, function(val) &#123; var m = new Snap.Matrix(); m.rotate((val/250)*360, 10+25, 100+15); // 注意，后面两位数是旋转中心点，属于绝对坐标，svg里节点的变换中心都是绝对坐标，和CSS的transform-origin取值不太一样 rect.transform(m); &#125;, 500, mina.easeout(), function() &#123; console.log('animation end'); anim_rotate(); &#125;);&#125;;anim_rotate();var anim_move = function() &#123; // 节点位移部分 Snap.animate(0, 250, function(val) &#123; var m = new Snap.Matrix(); m.translate(val, 0); g.transform(m); &#125;, 2000, mina.easeout(), function() &#123; console.log('animation end'); anim_move(); &#125;);&#125;;anim_move(); 上面两个动画用 CSS 的方式实现代码如下：12345678910111213141516171819202122232425262728@keyframes demo6 &#123; 100% &#123; transform: translate3d(250px, 0, 0); &#125;&#125;// 简单位移动画CSS版.demo6 &#123; animation: demo6 2s linear infinite both;&#125;@keyframes demo7_rotate &#123; 100% &#123; transform: rotate(360deg); &#125;&#125;@keyframes demo7_move &#123; 100% &#123; transform: translate3d(250px, 0, 0); &#125;&#125;// 旋转、位移符合动画CSS版.demo7 &#123; animation: demo7_move 2s linear infinite both; rect &#123; transform-origin: 35px 115px; animation: demo7_rotate .5s linear infinite both; &#125;&#125; 简单位移动画CSS版预览点此；旋转、位移符合动画CSS版预览点此。 五、几个兼容性说明及建议这部分会说一下笔者在开发过程中遇到的一些兼容性问题以及使用建议。当然还会有更多的笔者没遇到的问题，欢迎各位看官多多评论交流，不吝赐教。 总的来说，Snap 的 API 兼容性不错，官网声称兼容 IE9 及以上、Safari、Chrome、Firefox、Opera；而移动设备方面，经笔者测试 iOS、安卓 X5 内核、安卓原生浏览器兼容性都不错，文中的例子除了特殊说明外的都可以执行 作用于 svg 节点的 CSS transform 动画在安卓原生浏览器下兼容性不好， X5 则正常 在 iOS7 和 8 下 innerHTML 方法不能用于 svg 里 安卓原生浏览器绘制 svg 图形很可能会产生渲染模糊的现象（如下图），在 svg 里加上一个 text 节点即可神奇的修复 这样的节点 &lt;text&gt;a&lt;/text&gt; 即可修复模糊的问题，但不能 display:none 隐藏 在使用建议方面： 一般来说，transform 动画可以优先使用 CSS 的方式实现，但如果需要复杂的分段控制或者更好的兼容性，可以试试 Snap 的 transform&amp;matrix 方式 Snap 的有些动画需要大量计算，虽然 svg 里的节点属于“绝对定位”，动画时一般不会引起重排（参考下图），但在移动设备上也要注意动画元素不宜过多。以 image 动画为例， 经笔者测试，150x150 左右的图片动画节点控制在 10 个左右基本能达到大部分机型的性能要求 滤镜类属性在移动设备上不宜做动画 小飞机动画在 chrome 的渲染层边界图： 橙色边为 svg 的边界（即渲染层，为了便于查看 svg 节点经过了 transform:rotateY(30deg) ；绿色为重绘部分。可以看出 svg 里的动画元素只会引起重绘，而里面的节点用 translateZ 也并不会新开一个渲染层。 六、参考资料Snap.svg官网 Web动画API教程5：可爱的运动路径（Motion Path) 张鑫旭：Snap.svg API中文文档兼demo实例页面","pubDate":"Sun, 22 Jan 2017 15:55:00 GMT","guid":"https://aotu.io/notes/2017/01/22/snapsvg/","category":"Web开发"},{"title":"sass-svg 一个内联 SVG 的 SASS 库","link":"https://aotu.io/notes/2017/01/19/sass-svg/","description":"一、CSS内联 SVG一直觉得 内联 SVG 是 HTML 的延伸，但是内联 SVG 往往会造成HTML结构的臃肿。于是笔者尝试着把 SVG 移植到 CSS 中，如下： 12345background: url(&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"393.969\" height=\"28.219\" viewBox=\"0 0 393.969 28.219\"&gt; &lt;path d=\"M0.969,11.313 C-20.207,69.711 314.183,-47.984 393.969,24.312 \"/&gt;&lt;/svg&gt;) 目前（2017.01.12）而言，没有任何浏览器的 CSS 支持内联 SVG 代码，所以上述的代码是一段非法的 css。尽管任何浏览器的 CSS 都不支持内联 SVG 代码，但是所有的现代浏览都是支持内联 SVG 文件，如下： 1background: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA3NTAgNDAwIj4gCQkJPHBhdGggZD0iTTAsMCBMNzUwLDAgTDc1MCw0MDAgTDM4OCw0MDAgTDM3NSwzODcsIEwzNjIsNDAwIEwwLDQwMFoiIGZpbGw9IiMwZjAiPjwvcGF0aD4gCQk8L3N2Zz4=); 内联 SVG 文件即 Data-URI。 二、Data-URI 简介 A new URL scheme, “data”, is defined. It allows inclusion of small data items as “immediate” data, as if it had been included externally.摘录自：https://tools.ietf.org/html/rfc2397 简单地说，Data-URI 是一种将小文件转换成直接字面数据的方案(scheme)。Data-URI 的语法如下： 1data:[&lt;media type&gt;][;base64],&lt;data&gt; &lt;media type&gt;: 即指定嵌入数据的 MIME，对于 PNG 的图片，其格式是：image/png，如果没有指定，默认是：text/plain；[;base64]: base64 编码扩展，非必选项。如果没指定 base64 编码扩展，后面的 &lt;data&gt; 将使用 URL编码（即百分号编码）。&lt;data&gt;: 编码后的小文件数据。图片文件则是对二进制文件流进行编码，文本文件则是对文本进行编码。 附注：Data-URI 是正式术语，日常中更常用的名字是 Base64。 三、sass-svgsass-svg 是一个将 SVG 代码转化为 Data-URI 的 Sass 库。了解 Data-URI 后，sass-svg 的作用其实就是把 SVG 进行编码的过程。 1. URL编码在 JS 中可以使用 encodeURI 或 encodeURIComponent 来对字符进行 URL 编码，而 Sass 并没有相对就的编码方法。了解一下 URL编码的知识点： URL 编码的原理：ASCII 字符 = % + 两位 ASCII 码（十六进制）。例如，字符 a 对应的 ASCII 码为 0x61，那么 URL 编码后得到 %61。 「rfc3986」规定 URL 只允许英文字母（a-zA-Z）、数字（0-9）、-_.~4个特殊字符以及保留字符(! * &#39; ( ) ; : @ &amp; = + $ , / ? # [ ])。 尽管 Sass 不提供获取 ASCII 码的函数，但创建一张 ASCII 字符 与 ASCII 码 的对照表(map) 却是廉价的。标准的 ASCII 字符一共是 128 个，剔除 rfc3986 规定的不需要编码的字符（84个），再把扣除一些控制符，实际上需要编码的字符只有 13 个，如下： 12345678910111213141516// ascii 与 16进制对照表$asciiHexMap: ( \" \": \"%09\", \" \": \"%20\", \"\\\"\": \"%22\", \"%\": \"%25\", \"/\": \"%2f\", \"&lt;\": \"%3c\", \"&gt;\": \"%3e\", \"\\\\\": \"%5c\", \"^\": \"%5e\", \"`\": \"%60\", \"&#123;\": \"%7b\", \"|\": \"%7c\", \"&#125;\": \"%7d\"); 实现 URL 编码要求 sass 版本3.3以上，因为需要用到三个内置函数：str_index、str_slice 和 str_insert。 实现 URL 编码的过程不详述，笔者已经将相关代码放到 GIT 仓库，有兴趣的同学可以访问 「sass-svg」。 注意：本文所描述的编码仅针对 US-ASCII 字符集。中文或其它字符不讨论 2. Base64 编码Base64 使用 US-ASCII 子集的64个字符，即大小写的26个英文字母，0～9，＋，/。如下： 12345678'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H','I', 'J', 'K', 'L', 'M', 'N', 'O', 'P','Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X','Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f','g', 'h', 'i', 'j', 'k', 'l', 'm', 'n','o', 'p', 'q', 'r', 's', 't', 'u', 'v','w', 'x', 'y', 'z', '0', '1', '2', '3','4', '5', '6', '7', '8', '9', '+', '/' Base64 编码总是基于3个字符，每个字符用8位二进制表示，因此一共24位，再分为4四组，每组6位表示一个 Base64 的值。如果不足3个字符，仍将每个字符对应的二进制串起，再按每组6位表示一个 Base64的值，不足6位的用 0补全，最后生成的 Base64 码不足4位用=补全。 举个例子来感受一下： 与 URL编码相似，SASS 无法直接获取 ASCII 字符对应的二进制，也无法将6位二进制转成 Base64 码。这意味着需要手动创建两张对照表(map)。如下： 123456789101112131415161718192021222324252627// ascii字符 与 8位二进制 对照表$asciiMap: ( \" \": \"00001001\", \" \": \"00100000\", \"!\": \"00100001\", \"\\\"\": \"00100010\", \"#\": \"00100011\", \"$\": \"00100100\", \"%\": \"00100101\", \"&amp;\": \"00100110\", \"'\": \"00100111\", \"(\": \"00101000\", \")\": \"00101001\", \"*\": \"00101010\", \"+\": \"00101011\", \",\": \"00101100\", \"-\": \"00101101\", \".\": \"00101110\", \"/\": \"00101111\", \"0\": \"00110000\", \"1\": \"00110001\", \"2\": \"00110010\", \"3\": \"00110011\", \"4\": \"00110100\", \"5\": \"00110101\", \"6\": \"00110110\", \"7\": \"00110111\", \"8\": \"00111000\", \"9\": \"00111001\", \":\": \"00111010\", \";\": \"00111011\", \"&lt;\": \"00111100\", \"=\": \"00111101\", \"&gt;\": \"00111110\", \"?\": \"00111111\", \"@\": \"01000000\", \"A\": \"01000001\", \"B\": \"01000010\", \"C\": \"01000011\", \"D\": \"01000100\", \"E\": \"01000101\", \"F\": \"01000110\", \"G\": \"01000111\", \"H\": \"01001000\", \"I\": \"01001001\", \"J\": \"01001010\", \"K\": \"01001011\", \"L\": \"01001100\", \"M\": \"01001101\", \"N\": \"01001110\", \"O\": \"01001111\", \"P\": \"01010000\", \"Q\": \"01010001\", \"R\": \"01010010\", \"S\": \"01010011\", \"T\": \"01010100\", \"U\": \"01010101\", \"V\": \"01010110\", \"W\": \"01010111\", \"X\": \"01011000\", \"Y\": \"01011001\", \"Z\": \"01011010\", \"[\": \"01011011\", \"\\\\\": \"01011100\", \"]\": \"01011101\", \"^\": \"01011110\", \"_\": \"01011111\", \"`\": \"01100000\", \"a\": \"01100001\", \"b\": \"01100010\", \"c\": \"01100011\", \"d\": \"01100100\", \"e\": \"01100101\", \"f\": \"01100110\", \"g\": \"01100111\", \"h\": \"01101000\", \"i\": \"01101001\", \"j\": \"01101010\", \"k\": \"01101011\", \"l\": \"01101100\", \"m\": \"01101101\", \"n\": \"01101110\", \"o\": \"01101111\", \"p\": \"01110000\", \"q\": \"01110001\", \"r\": \"01110010\", \"s\": \"01110011\", \"t\": \"01110100\", \"u\": \"01110101\", \"v\": \"01110110\", \"w\": \"01110111\", \"x\": \"01111000\", \"y\": \"01111001\", \"z\": \"01111010\", \"&#123;\": \"01111011\", \"|\": \"01111100\", \"&#125;\": \"01111101\", \"~\": \"01111110\"); 123456789101112131415161718192021// 二进制 与 base64 对照表$base64map: ( \"000000\": 'A', \"000001\": 'B', \"000010\": 'C', \"000011\": 'D', \"000100\": 'E', \"000101\": 'F', \"000110\": 'G', \"000111\": 'H', \"001000\": 'I', \"001001\": 'J', \"001010\": 'K', \"001011\": 'L', \"001100\": 'M', \"001101\": 'N', \"001110\": 'O', \"001111\": 'P', \"010000\": 'Q', \"010001\": 'R', \"010010\": 'S', \"010011\": 'T', \"010100\": 'U', \"010101\": 'V', \"010110\": 'W', \"010111\": 'X', \"011000\": 'Y', \"011001\": 'Z', \"011010\": 'a', \"011011\": 'b', \"011100\": 'c', \"011101\": 'd', \"011110\": 'e', \"011111\": 'f', \"100000\": 'g', \"100001\": 'h', \"100010\": 'i', \"100011\": 'j', \"100100\": 'k', \"100101\": 'l', \"100110\": 'm', \"100111\": 'n', \"101000\": 'o', \"101001\": 'p', \"101010\": 'q', \"101011\": 'r', \"101100\": 's', \"101101\": 't', \"101110\": 'u', \"101111\": 'v', \"110000\": 'w', \"110001\": 'x', \"110010\": 'y', \"110011\": 'z', \"110100\": '0', \"110101\": '1', \"110110\": '2', \"110111\": '3', \"111000\": '4', \"111001\": '5', \"111010\": '6', \"111011\": '7', \"111100\": '8', \"111101\": '9', \"111110\": '+', \"111111\": '/', \"======\": '=' // base64占位符); 实现过程不详述。有兴趣可以访问「sass-svg」。 3. sass-svg 的一个实例开头的非法 CSS，通过 sass-svg 可以改写成： 123456// scssbackground: url( sass-svg-base64('&lt;svg viewBox=\"0 0 393.969 28.219\"&gt; &lt;path d=\"M0.969,11.313 C-20.207,69.711 314.183,-47.984 393.969,24.312 \"/&gt; &lt;/svg&gt;')) 通过编译最终会生成： 1background: url(\"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzOTMuOTY5IDI4LjIxOSI+IAkJICA8cGF0aCBkPSJNMC45NjksMTEuMzEzIEMtMjAuMjA3LDY5LjcxMSAzMTQuMTgzLC00Ny45ODQgMzkzLjk2OSwyNC4zMTIgIi8+IAkJPC9zdmc+\"); 结语感谢阅读本文。关于 sass-svg 的应用，笔者会有后续文章介绍，如果喜欢本文请关注一下我们『凹凸实验室』的微信公众号：AOTULabs 参考资料 Data URI scheme - Wikipedia RFC 2397 - The “data” URL scheme Uniform Resource Identifier (URI): Generic Syntax Uniform Resource Locators (URL) Base64编码解码算法 Module: Sass::Script::Functions URL编码与解码原理 Base64编码解码算法","pubDate":"Thu, 19 Jan 2017 14:21:44 GMT","guid":"https://aotu.io/notes/2017/01/19/sass-svg/","category":"Web开发"},{"title":"微信小程序跨页面通信解决思路","link":"https://aotu.io/notes/2017/01/19/wxapp-event/","description":"宏观上，微信小程序是由一个个 Page 组成的。有时候我们会遇到一些业务存在耦合的 Page，一个 Page 里某个状态改变后，相关 Page 的状态需要进行更新。而在小程序里，每个 Page 都是一个模块，有着独立的作用域，因此 Page 间需要有一种通信策略。 想象一个业务场景，用户首先进入订单列表页。然后点击其中一个订单，进入到订单详情页。当用户在订单详情页对订单进行操作，例如支付、确认收货等时，该订单的状态就会发生改变。此时需要对上一级的订单列表页中该订单的状态进行更新： 要想更新订单列表页的视图层，就需要调用该 Page 对象的 setData 方法。这里为大家列举三种比较常用的方案： 设置标志位最简单的方法，在订单详情页对订单的操作成功回调中，把一些标志位设置为 true，并设置好参数（标志位和参数可以存在 localStorage 或挂在全局 App 对象下）。然后每次在订单列表页的 onShow 生命周期中，根据这些标志位去判断是否进行更新、更新的参数是什么。 这种处理在业务逻辑比较简单、页面间的耦合度很小时还能凑合，一旦逻辑复杂起来，就需要写很多冗余的代码，并且维护成本会非常高。 流程图： 利用页面栈获取 Page 对象如果订单详情页里能拿到订单列表页的 Page 对象，就能去调用它的 setData 方法。小程序提供了一个方法 getCurrentPages，执行它可以得到当前页面栈的实例，然后再根据页面进栈的顺序我们就能拿到订单列表页的 Page 对象。 然而这种做法的缺点还是耦合度太大，过度依赖页面进栈顺序。一旦在以后的产品迭代中页面顺序发生变化，将很难去维护。 流程图： 上述两种方法都存在着耦合度大、维护困难的问题，而利用发布／订阅模式能很好的实现解耦，下面我们先来了解一下这种设计模式。 发布／订阅模式（最优方案）发布／订阅模式由一个发布者、多个订阅者以及一个调度中心所组成。订阅者们先在调度中心订阅某一事件并注册相应的回调函数，当某一时刻发布者发布了一个事件，调度中心会取出订阅了该事件的订阅者们所注册的回调函数来执行。 在发布／订阅模式中，订阅者和发布者并不需要关心对方的状态，订阅者只管订阅事件并注册回调、发布者只管发布事件，其余一切交给调度中心来调度，从而能实现解耦。 在 app 跨页面通信这个问题上，iOS 端的 Notification Center、安卓端的 EventBus，也是通过这样一种设计模式去解决的，不过微信小程序内部并没有提供这种事件通知机制，所以我们需要手动去实现一个。 我们首先要实现一个 Event 类，它应该含有一个收集回调函数的对象，和提供三个基础方法：on（订阅）、 emit（发布）、 off（注销）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// event.jsclass Event &#123; /** * on 方法把订阅者所想要订阅的事件及相应的回调函数记录在 Event 对象的 _cbs 属性中 */ on (event, fn) &#123; if (typeof fn != \"function\") &#123; console.error('fn must be a function') return &#125; this._cbs = this._cbs || &#123;&#125; ;(this._cbs[event] = this._cbs[event] || []).push(fn) &#125; /** * emit 方法接受一个事件名称参数，在 Event 对象的 _cbs 属性中取出对应的数组，并逐个执行里面的回调函数 */ emit (event) &#123; this._cbs = this._cbs || &#123;&#125; var callbacks = this._cbs[event], args if (callbacks) &#123; callbacks = callbacks.slice(0) args = [].slice.call(arguments, 1) for (var i = 0, len = callbacks.length; i &lt; len; i++) &#123; callbacks[i].apply(null, args) &#125; &#125; &#125; /** * off 方法接受事件名称和当初注册的回调函数作参数，在 Event 对象的 _cbs 属性中删除对应的回调函数。 */ off (event, fn) &#123; this._cbs = this._cbs || &#123;&#125; // all if (!arguments.length) &#123; this._cbs = &#123;&#125; return &#125; var callbacks = this._cbs[event] if (!callbacks) return // remove all handlers if (arguments.length === 1) &#123; delete this._cbs[event] return &#125; // remove specific handler var cb for (var i = 0, len = callbacks.length; i &lt; len; i++) &#123; cb = callbacks[i] if (cb === fn || cb.fn === fn) &#123; callbacks.splice(i, 1) break &#125; &#125; return &#125; &#125; 具体调用方法App 是小程序的实例，在每个 Page 里都能通过执行 getApp 函数获取到它。我们可以把 Event 类的实例挂载在 App 中，方便每个 Page 去调用。 12345678// app.jsconst Event = require('./libs/event')App(&#123; event: new Event(), ...&#125;) 订单列表页在 onLoad 生命周期中订阅 “afterPaySuccess” 事件。 12345678910111213//order_list.jsvar app = getApp()Page(&#123; onLoad: function()&#123; app.event.on('afterPaySuccess',this.afterPaySuccess.bind(this)) &#125;, afterPaySuccess: function(orderId) &#123; ... &#125;, ...&#125;) 在订单详情页支付成功的回调中，发布 “afterPaySuccess” 事件,同时带上订单 id 参数。 1234567891011//order_detail.jsvar app = getApp()Page(&#123; raisePayment: function() &#123; ... app.event.emit('afterPaySuccess', orderId) &#125;, ...&#125;) 所有 Page 的 onUnload 生命周期，必须注销掉之前订阅的事件。注销方法 off 的调用姿势有三种，不过还是建议注销当前 Page 所订阅的事件，而不是注销所有的。 12345678910111213var app = getApp()Page(&#123; onUnload: function()&#123; // remove all app.event.off() // remove all callbacks app.event.off('afterPaySuccess') // remove specific callbacks app.event.off('afterPaySuccess', this.afterPaySuccess) &#125;, ...&#125;) 到此就结束了吗？还没有，按照我们的订阅、注销写法，在注销指定回调函数的时候，其实是永远注销不了的。 完善off方法为了让每个回调函数被调用时的 this 都指向对应的 Page 对象，必须在订阅时对回调函数绑定当前的上下文对象。 1app.event.on('afterPaySuccess',this.afterPaySuccess.bind(this)) 相当于 12345app.event.on('afterPaySuccess', function()&#123; var args = Array.prototype.slice.call(arguments) // fn、that分别为闭包起来的回调函数和page对象 return fn.apply(that, args)&#125;) 正因为 bind 方法会返回这样一个匿名函数，然后这个匿名函数会被加入到回调数组中。因此我们注销指定回调函数的时候，在回调数组中是找不到它的，也就永远无法注销。 为了保持我们原来的 emit 调用方式，我想过直接把 Function.prototype.bind 改写： 123456789Function.prototype.bind = function(that) &#123; var fn = this var cb = function()&#123; var args = Array.prototype.slice.call(arguments) return fn.apply(that, args) &#125; cb.fn = this return cb&#125; 然后再稍微修改一下 off 方法里的判断条件 1234567// remove specific callbacks...if (cb === fn || cb.fn === fn) &#123; callbacks.splice(i, 1) break&#125;... 在浏览器环境这种做法是可行的，但是在小程序侧则是失败的。因为我们定义的这些 function 在小程序里并不是 Function 的实例，那无论我怎样修改 Function 的 prototype 属性，function 并不会继承到。原因是小程序把 Function 给改写了： 1234//consoleFunction.toString()// \"function ()&#123;if(arguments.length&gt;0&amp;&amp;\"return this\"===arguments[arguments.length-1])return function()&#123;return e&#125;&#125;\" 优化方案在小程序环境中是不能偷懒了，需要把之前的代码改写一下。要把 Page 对象也传给调度中心保存起来，作为回调函数调用时的上下文对象。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//event.jsclass Event &#123; on (event, fn, ctx) &#123; if (typeof fn != \"function\") &#123; console.error('fn must be a function') return &#125; this._stores = this._stores || &#123;&#125; ;(this._stores[event] = this._stores[event] || []).push(&#123;cb: fn, ctx: ctx&#125;) &#125; emit (event) &#123; this._stores = this._stores || &#123;&#125; var store = this._stores[event], args if (store) &#123; store = store.slice(0) args = [].slice.call(arguments, 1) for (var i = 0, len = store.length; i &lt; len; i++) &#123; store[i].cb.apply(store[i].ctx, args) &#125; &#125; &#125; off (event, fn) &#123; this._stores = this._stores || &#123;&#125; // all if (!arguments.length) &#123; this._stores = &#123;&#125; return &#125; // specific event var store = this._stores[event] if (!store) return // remove all handlers if (arguments.length === 1) &#123; delete this._stores[event] return &#125; // remove specific handler var cb for (var i = 0, len = store.length; i &lt; len; i++) &#123; cb = store[i].cb if (cb === fn) &#123; store.splice(i, 1) break &#125; &#125; return &#125; &#125; 调用方法也需要改一下，不需要使用 bind 方法了，只需传入 Page 对象： 1app.event.on('afterPaySuccess', this.afterPaySuccess, this) 写在最后一个简单的事件类几十行代码就能写完了，但作为一个基础模块还是有很多可以优化和拓展的地方。有兴趣的同学可以研读一下 nodejs 的 event 模块:https://github.com/nodejs/node/blob/master/lib/events.js，里面对事件类做了很多优化和功能拓展。 另外，小程序的开发过程中相信大家都遇到了不少的坑和发现了一些可以优化的点。为了收集这些开发中的痛点，我们开了一个 issue-list：https://github.com/o2team/wxapp-issue-list/blob/master/issue-list.md，欢迎大家前来提 issue~ 参考 https://github.com/dannnney/weapp-event","pubDate":"Thu, 19 Jan 2017 12:27:00 GMT","guid":"https://aotu.io/notes/2017/01/19/wxapp-event/","category":"Web开发"},{"title":"ELF - 灵活可扩展的 HTML5 构建工具","link":"https://aotu.io/notes/2017/01/17/elf/","description":"ELF，意为小精灵，来自 War3 中暗夜精灵族的农民。 通常当我们开始一个新的 HTML5 场景营销活动项目时，需要创建项目目录，初始化基本的项目文件，然后再添加构建（grunt/gulp/webpack）相关的文件（一次两次三次…，像小精灵采木一样~)，目前有不少工具可以帮我们解决一部分这种重复性的工作，但不能完全的解决，于是，就有了小精灵 - ELF，官网：elf.aotu.io。 快速上手 安装 ELF 支持 Node &gt;= 4，通过 npm 全局安装 1npm install -g elf-cli 但是，由于网络的原因，直接安装估计多半都会在安装 node-sass 和 phantomjs 这两个包时失败，所以，强烈推荐使用下面的命令安装 1234# mac/linux$ SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ PHANTOMJS_CDNURL=https://npm.taobao.org/mirrors/phantomjs/ npm install -g elf-cli --registry=https://registry.npm.taobao.org# windows$ npm install -g elf-cli --registry=https://registry.npm.taobao.org --SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ --PHANTOMJS_CDNURL=https://npm.taobao.org/mirrors/phantomjs/ 安装好后，可以运行 elf --help 查看支持的命令和帮助说明。 初始化项目 假如我们现在要做一个向下整页滑屏的 HTML5 项目 12345678# 运行初始化命令，基于 swiper template 初始化项目$ elf init -t swiper demo-swiper# 进入项目目录，安装依赖$ cd demo-swiper &amp;&amp; npm install# 运行（开发模式）$ elf start 这样一个向下整页滑屏的 HTML5 项目就已运行在开发模式上，样式预处理自动编译、样式热加载等功能早已具备， 在此基础上，你就可以开始按照你的需求愉快的开发了。 部署 当项目开发完成之后，需要将代码合并压缩用于部署，运行 1elf build 会生成一个 dist 文件夹用于部署。 整个流程下来，基本解决了 HTML5 项目开发过程中项目初始化和构建部分的重复工作，已在团队内广泛使用，包括 Q4 京东品牌运营的10多个 H5 项目，如 皇家视频 京东精选 功能介绍ELF 主要包括三部分功能：项目构建、示例模板和通用组件。 项目构建现在在做 web 开发时，基本都会引入构建工具，常用的有 grunt、gulp 以及目前最流行的 webpack，再配合各种插件，好处就不多说了，相信每个使用者都有自己的体会和心得。 ELF 基于 webpack 同时整合了 webpack-dev-server sass-loader、less-loader、style-loader html-webpack-plugin postcss-loader、autoprefixer、postcss-plugin-px2rem、postcss-sprites、postcss-assets image-webpack-loader *-loader … 提供了 开发时样式热加载 支持 Sass、Less 和 Stylus 样式预处理自动编译 Autoprefixer 前缀补全 px -&gt; rem 自动转换 雪碧图合成 自动获取图片 width 和 height 部署构建时图片压缩 部署构建时代码合并压缩 有了这些功能，可以让我们在开发时更多的专注于需求实现上。 示例模板目前提供的 5 个模板项目 基础模板（base） 该示例展示了最基本的项目结构，没有提供额外的功能，可以通过该示例了解整个项目的构建 划屏模板（swiper） 滑屏示例，基于 swiper， 可基于该项目初始化实现滑动翻屏的项目。 场景切换模板（switcher） 场景切换示例，基于 swiper 和 anime.js，可基于该项目初始化实现滑动场景切换的项目。 3D全景模板（panorama） 全景示例，基于 three.js 和 orientation.js，可基于该项目初始化实现重力感应配合全景的项目。 视频播放模板（video） 在手机上使用 video 标签播放视频的基础示例。 通过这些示例，可以快速初始化项目，你也可以根据自己的需求，定制自己的初始项目。 通用组件在项目开发中，有些常用功能已被封装成通用组件，例如：swiper。Github 上有大量优秀的开源组件，基本上能满足你所有需求，本着轮子不嫌多的\u0001精神，也造了两个 elf-preloader.js 预加载图片和音频 elf-orientation.js 处理重力感应 欢迎试用并提供问题或优化反馈~~ 写在最后项目最初的形态是由几个整理的典型示例组成，经过两次迭代重构后变成了现在的样子，在开发过程中的灵感主要来自 create-react-app，并借鉴了其 webpack 配置项。后续计划把 示例模板 那块拆分出来（类似 vue-cli 那样以及基于 Electron 提供 GUI。 欢迎各位同学试用，特别是做 HTML5 场景营销活动的同学，如果在使用过程中遇到什么问题，欢迎提交 issues 和 PR,或者 FORK 构建自己的版本。 Github 地址","pubDate":"Tue, 17 Jan 2017 07:26:37 GMT","guid":"https://aotu.io/notes/2017/01/17/elf/","category":"NodeJS"},{"title":"聊聊 SVG 基本形状转换那些事","link":"https://aotu.io/notes/2017/01/16/base-shapes-to-path/","description":"一、前言前段时间研究 SVG 压缩优化，发现SVG预定义的 rect、circle、ellipse、line、polyline、polygon 六种基本形状可通过path路径转换实现，这样可以在一定程度上减少代码量。不仅如此，我们常用的 SVG Path 动画(路径动画)，是以操作path中两个属性值stroke-dasharray和stroke-dashoffset来实现，基本形状转换为path路径，有利于实现路径动画。 二、SVG基本形状SVG 提供了rect、circle、ellipse、line、polyline、polygon六种基本形状用于图形绘制，这些形状可以直接用来绘制一些基本的形状，如矩形、椭圆等，而复杂图形的绘制则需要使用 path 路径来实现。 1.rect 矩形12&lt;rect x=\"10\" y=\"10\" width=\"30\" height=\"30\"/&gt;&lt;rect x=\"60\" y=\"10\" rx=\"10\" ry=\"10\" width=\"30\" height=\"30\"/&gt; SVG中rect元素用于绘制矩形、圆角矩形，含有6个基本属性用于控制矩形的形状以及坐标，具体如下： 123456x 矩形左上角x位置, 默认值为 0 y 矩形左上角y位置, 默认值为 0width 矩形的宽度, 不能为负值否则报错, 0 值不绘制height 矩形的高度, 不能为负值否则报错, 0 值不绘制rx 圆角x方向半径, 不能为负值否则报错ry 圆角y方向半径, 不能为负值否则报错 这里需要注意，rx 和 ry 的还有如下规则： rx 和 ry 都没有设置, 则 rx = 0 ry = 0 rx 和 ry 有一个值为0, 则相当于 rx = 0 ry = 0，圆角无效 rx 和 ry 有一个被设置, 则全部取这个被设置的值 rx 的最大值为 width 的一半, ry 的最大值为 height 的一半 12345678910rx = rx || ry || 0;ry = ry || rx || 0;rx = rx &gt; width / 2 ? width / 2 : rx;ry = ry &gt; height / 2 ? height / 2 : ry;if(0 === rx || 0 === ry)&#123; rx = 0, ry = 0; //圆角不生效，等同于，rx，ry都为0&#125; 2.circle 圆形1&lt;circle cx=\"100\" cy=\"100\" r=\"50\" fill=\"#fff\"&gt;&lt;/circle&gt; SVG中circle元素用于绘制圆形，含有3个基本属性用于控制圆形的坐标以及半径，具体如下： 123r 半径cx 圆心x位置, 默认为 0cy 圆心y位置, 默认为 0 3.ellipse 椭圆1&lt;ellipse cx=\"75\" cy=\"75\" rx=\"20\" ry=\"5\"/&gt; SVG中ellipse元素用于绘制椭圆，是circle元素更通用的形式，含有4个基本属性用于控制椭圆的形状以及坐标，具体如下： 1234rx 椭圆x半径ry 椭圆y半径cx 圆心x位置, 默认为 0cy 圆心y位置, 默认为 0 4.line 直线1&lt;line x1=\"10\" x2=\"50\" y1=\"110\" y2=\"150\"/&gt; Line绘制直线。它取两个点的位置作为属性，指定这条线的起点和终点位置。 1234x1 起点的x位置y1 起点的y位置x2 终点的x位置y2 终点的y位置 5.polyline 折线1&lt;polyline points=\"60 110, 65 120, 70 115, 75 130, 80 125, 85 140, 90 135, 95 150, 100 145\"/&gt; polyline是一组连接在一起的直线。因为它可以有很多的点，折线的的所有点位置都放在一个points属性中： 1points 点集数列，每个数字用空白、逗号、终止命令符或者换行符分隔开，每个点必须包含2个数字，一个是x坐标，一个是y坐标 如0 0, 1 1, 2 2” 6.polygon 多边形1&lt;polygon points=\"50 160, 55 180, 70 180, 60 190, 65 205, 50 195, 35 205, 40 190, 30 180, 45 180\"/&gt; polygon和折线很像，它们都是由连接一组点集的直线构成。不同的是，polygon的路径在最后一个点处自动回到第一个点。需要注意的是，矩形也是一种多边形，如果需要更多灵活性的话，你也可以用多边形创建一个矩形。 1points 点集数列，每个数字用空白、逗号、终止命令符或者换行符分隔开，每个点必须包含2个数字，一个是x坐标，一个是y坐标 如0 0, 1 1, 2 2， 路径绘制完闭合图形” 三、SVG path 路径SVG 的路径&lt;path&gt;功能非常强大，它不仅能创建基本形状，还能创建更多复杂的形状。&lt;path&gt;路径是由一些命令来控制的，每一个命令对应一个字母，并且区分大小写，大写主要表示绝对定位，小写表示相对定位。&lt;path&gt; 通过属性 d 来定义路径， d 是一系列命令的集合，主要有以下几个命令： 通常大部分形状，都可以通过指令M(m)、L(l)、H(h)、V(v)、A(a)来实现，注意特别要区分大小写，相对与绝对坐标情况，转换时推荐使用相对路径可减少代码量，例如： 1234567// 以下两个等价d='M 10 10 20 20' // (10, 10) (20 20) 都是绝对坐标d='M 10 10 L 20 20'// 以下两个等价d='m 10 10 20 20' // (10, 10) 绝对坐标, (20 20) 相对坐标d='M 10 10 l 20 20' 四、SVG 基本形状路径转换原理1.rect to path如下图所示，一个 rect 是由 4 个弧和 4 个线段构成；如果 rect 没有设置 rx 和 ry 则 rect 只是由 4 个线段构成。rect 转换为 path 只需要将 A ~ H 之间的弧和线段依次实现即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344function rect2path(x, y, width, height, rx, ry) &#123; /* * rx 和 ry 的规则是： * 1. 如果其中一个设置为 0 则圆角不生效 * 2. 如果有一个没有设置则取值为另一个 */ rx = rx || ry || 0; ry = ry || rx || 0; //非数值单位计算，如当宽度像100%则移除 if (isNaN(x - y + width - height + rx - ry)) return; rx = rx &gt; width / 2 ? width / 2 : rx; ry = ry &gt; height / 2 ? height / 2 : ry; //如果其中一个设置为 0 则圆角不生效 if(0 == rx || 0 == ry)&#123; // var path = // 'M' + x + ' ' + y + // 'H' + (x + width) + 不推荐用绝对路径，相对路径节省代码量 // 'V' + (y + height) + // 'H' + x + // 'z'; var path = 'M' + x + ' ' + y + 'h' + width + 'v' + height + 'h' + -width + 'z'; &#125;else&#123; var path = 'M' + x + ' ' + (y+ry) + 'a' + rx + ' ' + ry + ' 0 0 1 ' + rx + ' ' + (-ry) + 'h' + (width - rx - rx) + 'a' + rx + ' ' + ry + ' 0 0 1 ' + rx + ' ' + ry + 'v' + (height - ry -ry) + 'a' + rx + ' ' + ry + ' 0 0 1 ' + (-rx) + ' ' + ry + 'h' + (rx + rx -width) + 'a' + rx + ' ' + ry + ' 0 0 1 ' + (-rx) + ' ' + (-ry) + 'z'; &#125; return path;&#125; 2.circle/ellipse to path圆可视为是一种特殊的椭圆，即 rx 与 ry 相等的椭圆，所以可以放在一起讨论。 椭圆可以看成A点到C做180度顺时针画弧、C点到A做180度顺时针画弧即可。 123456789101112function ellipse2path(cx, cy, rx, ry) &#123; //非数值单位计算，如当宽度像100%则移除 if (isNaN(cx - cy + rx - ry)) return; var path = 'M' + (cx-rx) + ' ' + cy + 'a' + rx + ' ' + ry + ' 0 1 0 ' + 2*rx + ' 0' + 'a' + rx + ' ' + ry + ' 0 1 0 ' + (-2*rx) + ' 0' + 'z'; return path;&#125; 3.line to path相对来说比较简单，如下： 123456789101112function line2path(x1, y1, x2, y2) &#123; //非数值单位计算，如当宽度像100%则移除 if (isNaN(x1 - y1 + x2 - y2)) return; x1 = x1 || 0; y1 = y1 || 0; x2 = x2 || 0; y2 = y2 || 0; var path = 'M' + x1 + ' '+ y1 + 'L' + x2 + ' ' + y2; return path;&#125; 4.polyline/polygon to pathpolyline折线、polygon多边形的转换为path比较类似，差别就是polygon多边形会闭合。 123456789101112131415// polygon折线转换points = [x1, y1, x2, y2, x3, y3 ...];function polyline2path (points) &#123; var path = 'M' + points.slice(0,2).join(' ') + 'L' + points.slice(2).join(' '); return path;&#125;// polygon多边形转换points = [x1, y1, x2, y2, x3, y3 ...];function polygon2path (points) &#123; var path = 'M' + points.slice(0,2).join(' ') + 'L' + points.slice(2).join(' ') + 'z'; return path;&#125; 五、convertpath 转换工具为了方便处理SVG基本元素路径转换，本人抽空写了convertpath工具，具体如下： 安装：1npm i convertpath 使用： 12345678910const parse = require('convertpath');parse.parse(\"./test/test.svg\")/** * &lt;circle cx=\"500\" cy=\"500\" r=\"20\" fill=\"red\"/&gt; */console.log(parse.toSimpleSvg())/** * &lt;path d=\"M500,500,m-20,0,a20,20,0,1,0,40,0,a20,20,0,1,0,-40,0,Z\" fill=\"red\"/&gt; */ 参考资料： Basic Shapes – SVG 1.1 (Second Edition)基本形状 - SVG | MDNSVG (一) 图形, 路径, 变换总结; 以及椭圆弧线, 贝塞尔曲线的详细解释路径 - SVG | MDNXMLDOM","pubDate":"Mon, 16 Jan 2017 04:36:37 GMT","guid":"https://aotu.io/notes/2017/01/16/base-shapes-to-path/","category":"web开发"},{"title":"视频H5のVideo标签在微信里的坑和技巧","link":"https://aotu.io/notes/2017/01/11/mobile-video/","description":"随着 4G 的普遍以及 WiFi 的广泛使用，手机上的网速已经足够稳定和高速，以视频为主的 HTML5 也越来越普遍了，相比帧动画，视频的表现更加丰富，前段时间开发了一个以视频为主的移动端 HTML5，在这里介绍一些实践经验。 统一播放效果我们希望视频播放时可以全屏播放，没有进度条、播放按钮等与系统相关的元素，可以在视频上方增加自定义的元素（比如一个跳过按钮），类型下面的效果： 在不同的操作系统（主要就是 iOS 和 Android），为了达到比较统一的播放效果，分别对其进行兼容。 iOS 在 iOS 上，APP 都是使用的系统自带的浏览器进行页面渲染，video 播放视频的效果是统一的，只需要考虑不同的 iOS 版本是否有不一致的地方。在 iOS 上，播放视频默认会弹出一个播放器全屏播放视频，如下效果 播放器上下有的系统默认的控制栏，可以控制视频的播放进度、音量以及暂停或继续播放，播放视频时，视频会 “浮” 在页面上，页面上的所有元素都只能是在视频下面，这种效果显然不是我们想要的。但好在 iOS 10 Safari 中，video 新增了 playsinline 属性，可以使视频内联播放。 在 webkit 的 blog 上提到 A note about the playsinline attribute: this attribute has recently been added to the HTML specification, and WebKit has adopted this new attribute by unprefixing its legacy webkit-playsinline attribute. This legacy attribute has been supported since iPhoneOS 4.0, and accordance with our updated unprefixing policy, we’re pleased to have been able to unprefix webkit-playsinline. iOS 10 之前的版本支持 webkit-playsinline，但是加了这个属性后，在 iOS 9 的上出现只能听到声音不能看到画面的问题，最后使用的标签代码 1&lt;video id=&quot;video&quot; class=&quot;video&quot; preload=&quot;auto&quot; playsinline src=&quot;http://wqs.jd.com/promote/superfestival/superfestival.mp4&quot; width=&quot;1&quot; height=&quot;1&quot; type=&quot;video/mp4&quot;&gt;&lt;/video&gt; 然后再加上这个库 iphone-inline-video一起使用。 Android 在 Android 上，因为各个软件使用的浏览器渲染引擎不一样，所以视频播放的效果差异也很大，这里主要以微信为主。微信使用的是自带的渲染引擎 TBS，默认的播放效果 在播放器的下方也是会有控制栏，视频也会 “浮” 在页面上。而 Android 是不支持 playsinline 属性使视频内联播放的。但是，如果你看过一些腾讯的视频类 HTML5，会发现它们在微信里是可以内联播放的，而这个功能是需要申请加入白名单的。 不过新版的 \u0002TBS 内核（&gt;=036849）支持一个叫 同层播放器 的视频播放器，这个不需要申请白名单，只需给 video 设置两个属性 x5-video-player-type=&quot;h5&quot; 和 x5-video-player-fullscreen=&quot;true&quot;，播放效果 当点击左上角的箭头的时，会退出播放 退出播放时，我们需要做相应的处理。TBS 有提供相应的事件，不过不同的版本有一点差异 TBS &lt; 036849 036849 &lt;= TBS &lt; 036900 036900 &lt;= TBS 是否支持同层播放器 否 是 是 退出全屏播放时触发 x5videoenterfullscreen x5videoexitfullscreen 进入全屏播放时触发 x5videoexitfullscreen x5videoenterfullscreen 通过监听这两个事件就可以知道当前的播放状态 1234567document.getElementById('video').addEventListener(\"x5videoexitfullscreen\", function()&#123; alert(\"exit fullscreen\")&#125;)document.getElementById('video').addEventListener(\"x5videoenterfullscreen\", function()&#123; alert(\"enter fullscreen\")&#125;) 在对话框中发送 //gettbs 可以查看相关信息，tbsCoreVersion 就是当前安装的 TBS 内核版本。 video 的事件video 支持的事件很多，但在有些事件在不同的系统上跟预想的表现不一致，在尝试比较之后，使用 timeupdate 和 ended 这两个事件基本可以满足需求 1234567video.addEventListener('timeupdate', function (e) &#123; console.log(video.currentTime) // 当前播放的进度&#125;)video.addEventListener('ended', function (e) &#123; // 播放结束时触发&#125;) 视频居中视频的宽高比是固定的，而手机的屏幕宽高比则不是，所以，为了让观看到的视频的体验尽可能一致，以宽度为先，进行适配 1234567891011121314function handleResize() &#123; var sWidth = 9 var sHeight = 16 var width = window.innerWidth var height = window.innerHeight var marginTop = height - (width * sHeight) / sWidth marginTop = Math.round(marginTop) if (marginTop &lt; -2) &#123; video.$wrapper.css('marginTop', marginTop / 2 + 'px') &#125; else &#123; video.$wrapper.css('marginTop', '0') &#125;&#125; 示例在线示例代码仓库 代码基于 ELF 构建，运行示例需要 安装 ELF，欢迎试用反馈。 参考 https://www.w3.org/wiki/HTML/Elements/video http://caniuse.com/#search=video https://developer.mozilla.org/zh-CN/docs/Web/Guide/Events/Media_events http://zhaoda.net/2014/10/30/html5-video-optimization https://webkit.org/blog/6784/new-video-policies-for-ios/ https://github.com/bfred-it/iphone-inline-video","pubDate":"Wed, 11 Jan 2017 09:36:37 GMT","guid":"https://aotu.io/notes/2017/01/11/mobile-video/","category":"Web开发"},{"title":"在微信小程序里实现图片预加载组件","link":"https://aotu.io/notes/2017/01/06/wxapp-img-loader/","description":"网页中的图片预加载我们知道在 Web 页面中实现图片的预加载其实很简单，通常的做法是在 JS 中使用 Image 对象即可，代码大致如下 12345var image = new Image()image.onload = function() &#123; console.log('图片加载完成')&#125;image.src = 'http://misc.360buyimg.com/lib/img/e/logo-201305.png' 然而在微信小程序（以下简称小程序）里要实现图片的预加载要更麻烦一些，因为小程序里并没有提供类似 Image 这样的 JS 对象。。 小程序必知必会在进入正题前，需要了解以下小程序相关的知识（当然最好还是完整的学习一下官方文档）： 小程序框架的核心是一个响应的数据绑定系统，整个系统分为视图层和逻辑层两块，视图层即页面模板（后缀为 .wxml 的文件），逻辑层即页面 JS 文件 小程序的页面模板由一系列的基础组件组合而成，如 view、text、button 等 页面内容的更新基于数据的单向绑定来进行，通过 JS 调用 Page 对象的 setData 方法来更新模板中绑定的数据 视图层到逻辑层的通信是通过事件完成的，在组件中声明事件的回调，JS 端可监听到界面交互的发生、组件状态的变化等 在 WXML 文件中，可通过 template 进行模板的复用，若 template 是在不同文件里定义的，需要先通过 import 语句进行引入 这里有个官方的简单例子可以用来帮助理解 123&lt;!-- 模板文件 foo.wxml --&gt;&lt;view&gt; Hello &#123;&#123;name&#125;&#125;! &lt;/view&gt;&lt;button bindtap=\"changeName\"&gt; Click me! &lt;/button&gt; 1234567891011//脚本文件 foo.jsPage(&#123; data: &#123; name: 'WeChat' &#125;, changeName: function(e) &#123; this.setData(&#123; name: 'MINA' &#125;) &#125;&#125;) 运行这个页面会看到一行 Hello WeChat! 的文字及一个按钮，点击按钮后文字会变成 Hello MINA! 在小程序中加载图片小程序提供一个 image 组件（类似于 HTML 中的 img 标签），可以设置 src 及加载成功或失败的回调，使用起来很简单 12&lt;!-- 模板文件 bar.wxml --&gt;&lt;image src=\"http://misc.360buyimg.com/lib/img/e/logo-201305.png\" bindload=\"imageOnLoad\" binderror=\"imageOnLoadError\" /&gt; 123456789//脚本文件 bar.jsPage(&#123; imageOnLoad(ev) &#123; console.log(`图片加载成功，width: $&#123;ev.detail.width&#125;; height: $&#123;ev.detail.height&#125;`) &#125;, imageOnLoadError() &#123; console.log('图片加载失败') &#125;&#125;) 运行以上代码，顺利的话页面上会显示出一张图片，同时控制台会打印出带图片宽高的日志信息 将功能抽离成公用组件接下来我们考虑实现这么一个功能，在页面上载入一张尺寸和 K 数都很大的图片，由于图片很大，下载需要一定的时间，而在这段时间内，用户看到的是空白或是不完整的图片，体验显然不好。 一种常用的优化手段是先加载一张缩略图，该缩略图通过样式设置为和原图一样的宽高，这样用户首先能很快速地看到一张模糊的图片，此时再去对原图做预加载，加载完成之后对缩略图进行替换，因为此时图片已经下载过了，所以界面上能无缝地切换为原图显示，效果如下： 完成这个优化操作的关键就在于需要一个公共的图片预加载组件的支持，接下来我们分步骤来看看如何实现 新建 demo 页面及组件相关的文件 img-loader.js 和 img-loader.wxml，组件需要和页面一样有个模板文件，是因为小程序里无法动态地插入模板结构。然后在 demo.wxml 里通过 import 语句引用组件模板，在 demo.js 里通过 require 语句将组件脚本进行引入 在页面中通过 template 调用组件模板并传入数据，这里我们传递一个名为 imgLoadList 的图片数组过去 在页面脚本中的 onLoad 方法中对组件进行初始化，并将 this 对象传入，因为组件内必须通过 Page 对象的 setData 来更新模板里的内容 在组件的 img-loader.js 中定义一个 load 方法用来创建一个图片的加载，将传入的 src 添加到加载队列中，并使用 setData 方法更新队列数据 接下来在组件 img-loader.wxml 中通过接收到的图片队列数据，用 wx:for 指令去生成 image 组件来对图片进行加载，同时将成功及失败的回调绑定到 img-loader.js 中的方法中，最终再回调回 Page 对象中 可以看出，由于小程序里无法动态地插入模板结构，所以相对于普通网页端的组件调用，这里多出了在 WXML 文件中引入及使用模板这个步骤，而其他部分对于调用方（即Demo 页面）来说则是相似的，下面是完整的 Demo 页面的代码 12345678910111213&lt;!-- demo.wxml --&gt;&lt;view class=\"img_wrap\"&gt; &lt;image wx:if=\"&#123;&#123; imgUrl &#125;&#125;\" src=\"&#123;&#123; imgUrl &#125;&#125;\" /&gt;&lt;/view&gt;&lt;button bindtap=\"loadImage\"&gt;Click To Load Image&lt;/button&gt;&lt;view class=\"msg\"&gt;&#123;&#123; msg &#125;&#125;&lt;/view&gt;&lt;!-- 引入图片预加载组件 --&gt;&lt;import src=\"../../img-loader/img-loader.wxml\"/&gt;&lt;template is=\"img-loader\" data=\"&#123;&#123; imgLoadList &#125;&#125;\"&gt;&lt;/template&gt; 123456789101112131415161718192021222324252627282930313233343536// ------ demo.js ------//引入图片预加载组件const ImgLoader = require('../../img-loader/img-loader.js')//缩略图 80x50 3KBconst imgUrlThumbnail = 'http://storage.360buyimg.com/mtd/home/lion1483683731203.jpg'//原图 3200x2000 1.6MBconst imgUrlOriginal = 'http://storage.360buyimg.com/mtd/home/lion1483624894660.jpg'Page(&#123; data: &#123; msg: '', imgUrl: '' &#125;, onLoad() &#123; //初始化图片预加载组件 this.imgLoader = new ImgLoader(this) &#125;, loadImage() &#123; //加载缩略图 this.setData(&#123; msg: '大图正拼命加载..', imgUrl: imgUrlThumbnail &#125;) //同时对原图进行预加载，加载成功后再替换 this.imgLoader.load(imgUrlOriginal, (err, data) =&gt; &#123; console.log('图片加载完成', err, data.src) this.setData(&#123; msg: '大图加载完成~' &#125;) if (!err) this.setData(&#123; imgUrl: data.src &#125;) &#125;) &#125;&#125;) 如果把图片加载完成的回调统一指定成 Page 对象中的方法，则可以很方便地处理多张图片的加载，这里也写了个例子，效果如下： 总的来说调用起来还算方便吧，img-loader 的组件代码略多这里就不贴出来啦，有兴趣的同学可以前往 Github 项目页面 查看，目前此组件已应用在京东购物小程序版中。Have Fun~","pubDate":"Fri, 06 Jan 2017 10:00:00 GMT","guid":"https://aotu.io/notes/2017/01/06/wxapp-img-loader/","category":"Web开发"},{"title":"第2季极客沙龙资料分享 - 知行·前端体验主题交流会","link":"https://aotu.io/notes/2017/01/04/geek-talks-s2/","description":"极客沙龙(Geek Talks)，没有固定的主办方，每Q一次，由凹凸实验室联合别的公司、团队一起举办的开放技术分享品牌，面向全栈，核心关注的是移动互联网的技术领域。 本季极客沙龙(Geek Talks) 为鹅厂Fit主办，凹凸实验室、QQ浏览器团队、腾讯TGideas团队联合协办，其主题为「知·行」。 事实上距分享会已过了整整7天，因为我最近拖沓的症状，今天才补上分享会的课件分享。而巧的是，关于治疗拖沓症的具体办法，恰巧可以参考本次分享会来自TGIdeas黄文杰同学分享的「前端开发的自我修养」。 小花絮抽奖签到券用sketch设计的简单抽奖签到券，虽然不是专业设计师，但是还能看吧。 给签到券印上编号心灵手巧的硬妹子EC，凹凸实验室的动效一姐，目前单身！ 茶歇听听分享，吃吃东西。 分享嘉宾合照前段时间「张小龙今天的一张照片，暴露了程序员的审美」刷屏了， 我们的嘉宾显然朝气蓬勃许多吧，左二、三，90后，上个月撸完京东首页改版，右一潮男，右三是会弹吉他的奶爸。 对于审美的话题，引用网友的一句评论：审美在能改变世界的人和金钱面前算个逑。 主题简评及课件下载重构眼中的微信小程序这个分享主要抛出了一种「以现有Web开发构建手段去开发微信小程序」的思路，有点类似「用Reactjs去开发原生APP」的感觉。微信小程序如果真能火起来，将来势必会有很多的开发小程序的工具、系统或框架。 课件下载：重构眼中的微信小程序 京东购物之微信小程序诞生记如果说前面的主题是对小程序的探索和构想，那末这个分享则是实际项目的总结分享。整个讲义非常详细地介绍了「京东购物小程序」的项目背景，分享了开发过程中的坑和技巧。 课件下载：京东购物之微信小程序诞生记 京东首页前端优化之路尽管是后PC时代，但是前端工程化构建以及极致优化的思想一直是热门且通用的课题。 这个分享主要介绍京东首页的整体技术架构和团队开发模式，以及在此次优化过程中所面临的性能、体验、页面可用性等方面的挑战和解决之道。 课件下载：京东首页前端优化之路 前端开发的自我修养 工作中没有脱离项目执行和管理的技术 本次极客沙龙唯一一个非技术性的分享，中间提及的工作思路和感悟可以受用在日常的技术实践过程中。 现在觉得无聊的童鞋可以过两年再回来看看，技术会更新迭代，而修养的话题却是持久不变。 课件下载：前端开发的自我修养 地铁线路图选站实践分享这位同学的SVG玩的很6. SVG在地铁线路图选站项目中的开发实践。技术实现之余，将一起思考探讨在大前端浪潮中，如何选择重构的工作范围，做与不做，一念之间，干系万千。 课件下载：地铁线路图选站实践分享 ServiceWorker介绍了传统WEB开发的痛点，并以DEMO的形式展示了 ServiceWorkers相关技术实践，以及相关进阶扩展和工具配置。 如果没记错，vue2.0的一个有名的开源案例vue-hackernews-2.0 也有SW的实际应用。 课件下载：ServiceWorker 下一季极客沙龙预告第3季将会是「微信小程序专场分享」，今年3月份举办，有兴趣的同学可以关注下。","pubDate":"Wed, 04 Jan 2017 03:35:12 GMT","guid":"https://aotu.io/notes/2017/01/04/geek-talks-s2/","category":"资源合集"},{"title":"一个栗子实践vue2.0与1.0的区别","link":"https://aotu.io/notes/2016/12/28/vue-clock/","description":"序言本文通过一个初熟的小栗子来实践2.0与1.0的不同之处，最终的效果如下图所示： 提示 可作为vue2.0+vuex入门参考 只粘贴核心代码，看源码建议直接下载demo 其实只有sass没有贴上啦 demo在移动端亲测可用 搭建项目知识点这个栗子将涉及以下知识点： vue2.0 vue-cli脚手架 vuex状态管理库 webpack 版本声明本篇文章的版本： node: v6.2.0 vue: v2.1.0 vuex: v2.0.0 vue-router: v2.1.1 webpack: v1.13.2 文件目录 安装首先请确保已安装了node、npm、webpack。 安装vue脚手架。 1npm install vue-cli -g 选择一个目录并执行。 1vue init webpack 项目名字 或者vue init webpack-simple 项目名字 &lt;注意不能用中文&gt; 然后根据命令行的相关提示输入信息； webpack与webpack-simple两者的区别在于webpack-simple没有包括eslint等功能，普通的项目用simple就好了； 我使用的是前者。 进入项目目录下载相关依赖。 12cd 项目目录npm install 启动。 1npm run dev 这一行命令会自动启动浏览器并运行项目(如果你不想占用8080端口，可通过 项目 /config/index.js 中的port修改)。 初始化初始化入口js文件 main.jsmain.js是应用入口文件，可以在这里 配置路由vue-router 引入路由子组件 引入状态管理store(注入所有子组件) 实例化Vue 引入公共样式等 已完成的main.js如下： 懒癌患者可直接拷贝 123456789101112131415161718192021222324252627282930313233343536373839import Vue from 'vue'import store from './store'//引入路由及组件import VueRouter from 'vue-router'import App from './App'import Home from './components/Home'import Clocklist from './components/Clocklist'//引入公共cssimport './static/css/reset.css'Vue.use(VueRouter)//定义路由const routes = [ &#123; path : '/', component : Home &#125;, &#123; path : '/home', component : Home &#125;, &#123; path : '/clocklist', component : Clocklist &#125;,]//创建实例const router = new VueRouter(&#123; routes&#125;)//实例化，并将store、router挂载到根实例，从而应用到整个项目new Vue(&#123; store, router, ...App&#125;).$mount('#app')//或者直接在options里声明挂载的el 与1.0的不同 映射路由：1.0是通过router的map方法映射路由，并且map接收的是一个对象，2.0中map()被替换了，通过实例化VueRouter并定义一个数组来映射路由； 初始化路由：1.0通过router.start()来初始化路由，2.0中router.start()被替换了，直接通过挂载到vue根实例进行初始化 初始化根组件App.vue在App.vue中添加路由，并引入Sidebar.vue组件，对应的样式直接写在每个独立的组件下，注意这里使用了sass语法，需在 ./build/webpack.base.conf.js 中配置，如下所示： 123456789101112vue: &#123; loaders: utils.cssLoaders(&#123; sourceMap: useCssSourceMap &#125;), postcss: [ require('autoprefixer')(&#123; browsers: ['last 2 versions'] &#125;), require('postcss-import'), require('postcss-sass-extend'), require('postcss-simple-vars'), require('postcss-nested')//sass嵌套语法，其他的看最后一个单词就知道是干什么的了 ] &#125; 下面附上整个App.vue的代码，注意看注释掉的部分哦。 从这里开始后面的sass不贴出来了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;template&gt; &lt;!-- 不加会报错 --&gt; &lt;div class=\"clock_wrap\"&gt; &lt;!--S 头部 --&gt; &lt;section class=\"clock_header\"&gt; &lt;h1&gt;计时器&lt;/h1&gt; &lt;/section&gt; &lt;!--E 头部 --&gt; &lt;section class=\"clock_container\"&gt; &lt;!--S 导航 --&gt; &lt;nav class=\"clock_nav\"&gt; &lt;router-link to=\"/home\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/clocklist\"&gt;计时列表&lt;/router-link&gt; &lt;/nav&gt; &lt;!--E 导航 --&gt; &lt;!--S sidebar --&gt; &lt;div class=\"clock_sidebar\"&gt; &lt;sidebar&gt;&lt;/sidebar&gt; &lt;/div&gt; &lt;!--E sidebar --&gt; &lt;!--S 路由部分 --&gt; &lt;div class=\"clock_router\"&gt; &lt;!-- &lt;transition mode=\"out-in\"&gt; --&gt; &lt;transition :name=\"transitionName\"&gt; &lt;router-view class=\"clock_router_inner\"&gt;&lt;/router-view&gt; &lt;/transition&gt; &lt;/div&gt; &lt;!--E 路由部分 --&gt; &lt;/section&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Sidebar from './components/Sidebar.vue'export default &#123; data:function()&#123; return &#123; transitionName: 'slide-left' &#125; &#125;, mounted:function()&#123; if(this.$route.name==undefined)&#123; this.$router.push('home'); &#125; &#125;, /*watch: &#123; '$route' (to, from) &#123; console.log(to.path) &#125; &#125;,*/ components: &#123; Sidebar &#125;&#125;&lt;/script&gt;&lt;style&gt;@import './static/sass/_function.scss';body &#123; overflow: hidden;&#125;.clock_header &#123; height: 42px; line-height: 42px; background: #39383e; h1 &#123; font-size: 18px; color: #fff; text-align: center; &amp;::before &#123; content: ''; width: 18px; height: 18px; display: inline-block; vertical-align: middle; margin: -2px 5px 0 5px; background: url(./static/img/logo.png) no-repeat; background-size: 100% 100%; &#125; &#125;&#125;.clock_nav &#123; height: 36px; line-height: 36px; background: #f0eff5; padding-left: 5px; font-size: 0; a &#123; display: inline-block; padding: 0 10px; position: relative; font-size: 14px; &amp;.router-link-active &#123; color: $color_red; &#125; &amp;:not(:last-child) &#123; &amp;::after &#123; content: ''; width: 1px; background: #e1e0e6; position: absolute; right: 0; top: 12px; bottom: 12px; &#125; &#125; &#125;&#125;.clock_container &#123; @extend %clearfix;&#125;.clock_sidebar &#123; width: 30%; float: left; box-sizing: border-box; border: 1px solid #ddd; margin-top: 10px;&#125;.clock_router &#123; width: 70%; float: left; position: relative; &amp;_inner &#123; position: absolute; left: 0; right: 0; top: 0; transition: all .3s linear; &#125;&#125;.slide-left-enter&#123; opacity: 0; transform: translate3d(60px, 0, 0);&#125;.slide-left-leave-active &#123; opacity: 0; transform: translate3d(-60px, 0);&#125;&lt;/style&gt; 这里我将路由样式设置为相对定位，路由的子组件设置为绝对定位，可以解决切换路由的时候页面抖动问题。 与1.0的不同 根元素：在2.0中template下需要有一个根元素（clock_wrap），否则会报错； 路由导航：在1.0中我们通过v-link来指定导航链接，在2.0中可以直接使用router-link组件来导航，在浏览器中渲染后是一个a标签,并且会自动设置选中的class属性值.router-link-active， 然后通过to 属性指定链接； 过渡：在1.0中通过在目标元素（router-view）使用transition与transition-mode添加过渡，在2.0中，则改成了使用transition标签包裹目标元素，可以自定义name过渡，也可以使用自带的mode添加过渡动效(如mode=”out-in”)，2.0中也支持通过$route设置基于路由的动态过渡； 钩子：在1.0中的ready已经被mounted取代，此外2.0还新增了beforeMount、beforeUpdate、update等，下面是1.0与2.0生命周期示意图 1.0 2.0 创建首页Home.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;template&gt; &lt;div class=\"clock_time\"&gt; &lt;!-- &lt;div class=\"clock_time_inner\" v-html = \"time\"&gt; --&gt; &lt;div class=\"clock_time_inner\"&gt; &lt;i&gt;&#123;&#123;hour&#125;&#125;&lt;/i&gt; &lt;span&gt;:&lt;/span&gt; &lt;i&gt;&#123;&#123;minute&#125;&#125;&lt;/i&gt; &lt;span&gt;:&lt;/span&gt; &lt;i&gt;&#123;&#123;second&#125;&#125;&lt;/i&gt; &lt;/div&gt; &lt;div class=\"clock_time_btn\"&gt; &lt;span @click = 'doClock' v-bind:id=\"clockId\"&gt;开始计时&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; //time: '', hour: '', minute: '', second: '', clockId: 'clock_time' &#125; &#125;, mounted () &#123; this.nowTime() &#125;, methods: &#123; nowTime () &#123; const t = new Date(), h = t.getHours(), m = t.getMinutes(), s = t.getSeconds() //this.$data.time = '&lt;i&gt;' + h +'&lt;/i&gt;&lt;span&gt;:&lt;/span&gt;&lt;i&gt;' + m +'&lt;/i&gt;&lt;span&gt;:&lt;/span&gt;&lt;i&gt;' + s + '&lt;/i&gt;' this.$data.hour = h this.$data.minute = m this.$data.second = s setTimeout(() =&gt; &#123; this.nowTime() &#125;, 1000) &#125;, doClock () &#123; const nowTime = new Date() //状态 this.$store.dispatch('changeStatus') //时长 this.$store.dispatch('addDuration') //计时列表 this.$store.dispatch('saveClockList', nowTime) &#125; &#125; &#125;&lt;/script&gt; 通过nowTime ()方法获取当前的时间，doClock ()分别变更状态、时长以及存储计时记录，后面会讲到vuex部分。 与1.0的不同 数据绑定：与1.0一样绑定数据的形式都使用“Mustache” 语法，但2.0不能在html属性中使用了，比如栗子中的绑定id 的方法v-bind:id=”clockId”而不能直接使用{{clockId}}，否则会报错； 真实的html：1.0中输出真实的html是使用三个大括号{{{ }}}，2.0之后需要使用v-html指令，如上面注释掉的部分所示； 创建侧边栏Sidebar.vue12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=\"clock_sidebar_inner\"&gt; &lt;div class=\"clock_sidebar_item\"&gt; &lt;span class=\"clock_sidebar_title\"&gt;状态&lt;/span&gt; &lt;span class=\"clock_sidebar_desc\" :class = \"&#123; 'green': status == '已计时', 'red': status == '已结束' &#125;\"&gt;&#123;&#123; status &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;div class=\"clock_sidebar_item\"&gt; &lt;span class=\"clock_sidebar_title\"&gt;时长&lt;/span&gt; &lt;span class=\"clock_sidebar_desc\"&gt;&#123;&#123; duration &#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; computed: &#123; status() &#123; return this.$store.getters.getStatus &#125;, duration() &#123; return this.$store.getters.getDuration &#125; &#125; &#125;&lt;/script&gt; 通过计算属性computed去获取状态与时长。 继续创建打卡列表Clocklist.vue1234567891011121314151617181920&lt;template&gt; &lt;div class=\"clock_record\"&gt; &lt;div class=\"clock_record_nothing\" v-if = \"!list.length\"&gt;没有记录&lt;/div&gt; &lt;div class=\"clock_record_item\" v-else = \"list.length &gt; 0\" v-for = \"(item, index) in list\"&gt; &lt;div class=\"clock_record_name\"&gt;&lt;i&gt;&#123;&#123;index + 1&#125;&#125;&lt;/i&gt;&#123;&#123; item.date &#125;&#125;&lt;/div&gt; &lt;div class=\"clock_record_desc\"&gt;计时开始 &#123;&#123; item.gotowork &#125;&#125;&lt;/div&gt; &lt;div class=\"clock_record_desc\"&gt;计时结束 &#123;&#123; item.gooffwork &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; computed: &#123; list () &#123; return this.$store.getters.switchTime &#125; &#125; &#125;&lt;/script&gt; 与1.0的不同 v-else-if：在2.0中新增了v-else-if，类似于js中的else if，不能单独使用，需跟在v-if之后； v-for：在使用v-for遍历对象的时候，当存在index时，1.0的参数顺序是(index, value)，2.0变成了(value, index)； v-for：1.0中，v-for块内有一个隐性的特殊变量$index可以获取当前数组的索引，在2.0中移除了，改为了以上这种显式的定义方式； key：key替代track-by vuex部分vuex是为vue.js设计的一个状态管理模式，主要是用来存储共享状态、实现数据通信，简单理解就是统一管理和维护各个vue组件的状态 ，它可以解决多层嵌套组件的传参、兄弟组件的状态传递等难题， 代码更结构化且容易维护。核心概念包括State、Getters、Mutations、Actions、Modules。 创建index.js在src目录新建store文件夹用来存放共享数据(vuex)，然后新建index.js，用来初始化并导出 store。 store已经在main.js中引入 12345678910111213141516import Vue from 'vue'import Vuex from 'vuex'import state from './state'import getters from './getters'import mutations from './mutations'import actions from './actions'Vue.use(Vuex)export default new Vuex.Store(&#123; state, getters, mutations, actions strict: process.env.NODE_ENV !== 'production', //是否开启严格模式&#125;) strict为是否开启严格模式，在这种模式下任何状态变更不是由Mutation函数触发的都会报错，但是为了避免性能损失，不要在发布环境开启严格模式；在构建大型应用时，store对象会变的非常臃肿，Vuex允许将store分割为模块（module）,每个模块有自己个State、Mutations、Actions、Getters。 12345678910111213141516171819const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;) 创建state.js在store目录下继续创建state.js,代码如下 123456789const state = &#123; status: '已结束', duration: '0', timer: null, len: 0, clockList: []&#125;export default state Vuex使用一个state包含了全部的应用层级状态–也就是一个单一状态树；通常在计算属性(computed)返回(检测到数据发生变动时就会执行对相应数据有引用的函数)，如下：12345computed: &#123; list () &#123; return this.$store.state.status &#125;&#125; 创建mutations.js在store目录下继续创建mutations.js。 12345678910111213141516171819202122232425262728293031import * as types from './mutation-types'export default &#123; [ types.CHANGE_STATUS ] ( state) &#123; if( state.status === '已结束' ) &#123; state.status = '已计时' &#125;else if(state.status === '已计时') &#123; state.status = '已结束' &#125; &#125;, [ types.ADD_DURATION ] ( state, obj ) &#123; if( state.status === '已计时' ) &#123; state.duration = obj.time state.timer = obj.timer &#125;else &#123; clearInterval(obj.timer) &#125; &#125;, [ types.SAVE_CLOCK_LIST] (state, nowTime) &#123; if( state.status === '已计时' ) &#123; console.log(state.clockList.length) state.len = state.clockList.length state.clockList.push(&#123;\"gotowork\": nowTime, 'gooffwork': ''&#125;) &#125; if( state.status === '已结束' ) &#123; state.clockList[state.len].gooffwork = nowTime &#125; &#125; &#125; mutations是注册各种数据变化的方法，它接受state作为第一个参数，需注意以下几点 变更state必须通过mutation提交，这样使得我们可以方便地跟踪每一个状态的变化 mutation 必须是同步函数，异步应在action操作 通常使用常量替代mutation事件类型,在实际操作中通常会建立一个mutation-types.js来存储mutation常量，这样的好处是可以对整个 app 包含的 mutation 一目了然 创建mutation-types.js在store目录下继续创建mutation-types.js，用来存储mutation事件名 123export const CHANGE_STATUS = 'CHANGE_STATUS'export const ADD_DURATION = 'ADD_DURATION'export const SAVE_CLOCK_LIST = 'SAVE_CLOCK_LIST' 创建actions.jsaction类似autation，与之不同的是： action不能直接变更state，而是提交mutation action可包含异步操作，而mutation不能（严格模式下报错） Action基本语法如下： 12345actions: &#123; someMethod (context) &#123; context.commit('someMethod') &#125;&#125; action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。在实践中，通常使用 ES2015 的 参数解构简化代码，如下： 12345actions: &#123; someMethod (&#123; commit &#125;) &#123; commit('someMethod') &#125;&#125; 最后附上actions.js的所有代码 1234567891011121314151617181920212223242526272829303132333435import * as types from './mutation-types'export default &#123; changeStatus(&#123; commit &#125;) &#123; commit(types.CHANGE_STATUS) &#125;, addDuration(context) &#123; let num = 1, obj = &#123;&#125; if(context.state.status === '已计时') &#123; obj.timer = setInterval(() =&gt; &#123; let h = parseInt(num / 3600), m = parseInt(num / 60), s = num if(s &gt;= 60) &#123; s = s % 60 &#125; if(m &gt;= 60) &#123; m = m % 60 &#125; obj.time = h + '时' + m + '分' + s + '秒' context.commit(types.ADD_DURATION, obj) num ++ &#125;, 1000) &#125;else &#123; context.commit(types.ADD_DURATION, obj) &#125; &#125;, saveClockList(&#123; commit &#125;, nowTime) &#123; commit(types.SAVE_CLOCK_LIST, nowTime) &#125;&#125; 创建getters.js12345678910111213141516171819202122232425262728export default &#123; getStatus:state =&gt; state.status, getDuration:state =&gt; state.duration, switchTime:state =&gt; &#123; //转换前 let date = '', toTime = '', offTime = '', list = [] //转换后 let switchDate = '', switchToTime = '', switchOffTime = '' state.clockList.forEach(function (v, i) &#123; switchDate = v.gotowork.getFullYear() + '年' + ( v.gotowork.getMonth() + 1 ) + '月' + v.gotowork.getDate() switchToTime = v.gotowork.getHours() + ':' + v.gotowork.getMinutes() + ':' + v.gotowork.getSeconds() if(v.gooffwork !== '') &#123; switchOffTime = v.gooffwork.getHours() + ':' + v.gooffwork.getMinutes() + ':' + v.gooffwork.getSeconds() &#125;else &#123; switchOffTime = '' &#125; list.push(&#123;'date': switchDate, 'gotowork': switchToTime, 'gooffwork': switchOffTime&#125;) &#125;) return list &#125;&#125; getter接收state作为第一个参数，我们可以通过它 获取state的状态 对需要返回的数据进行处理，如过滤、转换等 关于代码结构只要遵守了vuex的规则，如何组织代码可根据项目的实际情况以及个人、团队的使用习惯，vuex并不会限制你的代码结构。所以，放开手脚一起搞事吧！ 以上就是整篇文章的所有内容，如有错误，恳请指正！ 反正咱也不改 写在最后不得不说前端的技术更新真是快啊，从来没有哪个行业像前端这样繁荣却又令人不安。作为前端人，我们唯有保持对新技术敏锐的嗅觉与热情，才能避免被技术前进的浪潮拍在沙滩上，正所谓路漫漫其修远兮，吾将…好了好了，搬砖去了… 参考资料http://cn.vuejs.org/v2/guide/http://vuex.vuejs.org/zh-cn/getting-started.htmlhttps://gold.xitu.io/post/583d1fe00ce463006baca2fahttps://aotu.io/notes/2016/10/13/vue2/","pubDate":"Wed, 28 Dec 2016 09:35:12 GMT","guid":"https://aotu.io/notes/2016/12/28/vue-clock/","category":"Web开发"},{"title":"京东2016版首页改版前端总结","link":"https://aotu.io/notes/2016/12/26/jd-index-2016-summary/","description":"深圳的天气总是多变，前一段时间还是凉意浓浓，似乎要步入冬天了，最近却又变得炎热起来，气温骤升，让人措手不及。正如我们负责的业务一样，一年下来有诸多变化。今年9月份我们接手了京东2016版首页改版开发，历经1个多月紧张地开发测试，终于在双11前成功全量发布，回想整个开发历程，感觉还是有很多值得思索的地方，例如北京一月，虽然日夜颠倒，加班不止，但整个人居然胖了许多，不禁让人匪夷所思。 整体架构最初听说要做新版京东首页的时候，是怀有一丝惶恐的，毕竟是作为京东的门户，其重要性和受关注程度自然不言而喻，一行代码的失误可能会造成不可挽回的后果，而且过去的首页无论性能，还有体验在业界都已经是做得非常优秀了，要再想有些出彩的地方，也是十分困难，所以综上就是压力山大。当然，花开两朵，咱们单表一枝，本文主要还是相对这次改版工作中提炼的工作方法和优化方式做出一定的总结。 这次改版，在前端架构上大体还是沿用过去的架构，使用 jQuery + Seajs 这种古老的开发方式，因为首页还依赖着许多旧的系统与组件，无法在短时间内对基础架构进行升级，当然并不是说旧的就不好，要去盲目追求一些新的东西，而是这种架构还是有可以提升的地方。 而整个项目的架构是经历之前业务进行总结提炼出来的 Athena前端工程化工具，是我们团队自己探索开发的一套基于NodeJs的命令行式前端工程化工具，解决了自动化编译、代码处理、依赖分析、文件压缩等前端开发中的常规问题，有效地提升了我们的工作效率，解放生产力，目前已经应用于我们团队的多个业务中，首页改版也使用Athena来进行开发； Athena管理平台，是Athena工具配套的管理后台，它会收集本地工具操作中上报的统计数据，包括项目、模块、页面、组件创建的信息，文件、资源依赖关系的信息等，通过这些数据来进行项目和资源的管理，同时提供了项目模板，方便使用本地工具创建项目时选择，具体可以参考之前的博文我们是如何做好前端工程化和静态资源管理； Athena组件平台，是基于Athena总结的一套业务组件的平台，可以很好地管理我们的业务组件，方便组件的复用和传播； Athena基础库及组件库，是业务中总结出的基于jQuery + Seajs的js库，简化业务开发，提供完整的框架； Athena模拟接口，可以自由编辑生成指定接口的假数据，用于开发时真实接口的替代，让开发不再依赖后端接口； Athena兜底接口服务，可以指定接口生成一份兜底数据接口，平台会定时去抓取指定接口数据，然后生成兜底数据到CDN，从而生成对应的兜底接口，这样让正常接口多一份兜底保障； Athena前端监控，通过在页面中进行埋点上报的方式，我们可以在监控系统中，实时地看到性能相关数据。我们进行上报的不止有页面性能、速度相关的数据，同时会上报用户的环境信息，例如操作系统、浏览器、网速等，而且还会对页面中错误信息进行上报，如模块的隐藏等，通过这些数据，对我们的业务进行实时地监控与分析。 在我们的架构中，各种各样的工具与系统相辅相成，覆盖到了开发到上线的各个环节，自成一套体系。这样的架构不止是针对首页这个业务的，而是在基于对之前业务开发总结的基础上进行完善、调整的架构，适用于我们各个业务。而这次首页的改版中，我们对开发模式、性能优化、体验优化都进行了一些新的探索，让我们对于业务开发的整体解决方案又有了新的改进。 开发模式Athena开发效率的提升是我们一直追求的，工欲善其事，必先利其器，我们通过总结以往的开发工作，提出了各种手段来优化我们的开发效率，前端工具Athena就是其中的一个产物，当然它又不仅仅是为了提升开发效率而已，它是我们总结出的一套针对前端开发的完整解决方案，可以让我们的整体开发流程更加简单明了。 Athena提供了统一的项目架构，根据业务功能不同，我们将一个项目(app)拆分成不同的业务模块(module)，而每一个模块都包含自身的页面(page)以及构成页面所需要的组件(widget)。 在本地使用Athena创建完整的项目结构，随后我们就可以只关注代码逻辑的书写，Athena提供了简便的操作命令可以一键式地实时编译预览我们的页面，从而让我们不必去关心文件处理、代码编译等细节，开发完后，可以通过Athena执行完整的编译步骤并同步到我们的服务器上方便进行浏览测试。 使用Athena，新版首页开发模式大致如下： 前后端分离基于Athena工具，我们目前已经可以做到完全地本地开发调试了，但是还并不能做到完全的前后端分离，以过去首页为例，页面被拆分成首屏和楼层，首屏采用直出的方式以提升速度，楼层则使用异步加载的方式，拉取服务器上已经渲染好的HTML字符串，如图 整个页面，包括首屏和楼层，都需要前端写好静态HTML，然后给后端开发同学来套用，转成后端语言对应的模板，这样导致前后端耦合较深，HTML更新极不方便，开发成本较高。 为了解决这样前后端耦合的问题，减少沟通成本，这次首页改版我们使用了新的开发方式，为了保证首屏速度，首屏依然采用直出的方式，但对非首屏的楼层进行改进，使用前端模板 + 数据开发方式，将DOM字符串的渲染放到前端来做，后端只提供数据接口，以此来达到前后端分离的效果，同时在开发中使用假数据平台模拟接口，让前端工作不再依赖后端。 在最开始提出这样前后端分离方案的时候还是受到了不少的质疑，因为使用前端模板 + 数据开发方式，会使得每个楼层都多一个接口，并且需要依靠JS来动态渲染，会影响到楼层加载的性能，但经过我们的测试证明在现代PC浏览器下两种模式前端渲染和后端渲染并不会相差太多，并且在模板、数据双重缓存下，这样的差距更是微乎其微了，更关键的是能让我们的开发效率有所提升。 当然，我们对于性能的追求总是孜孜不倦，为了让楼层的加载速度更快，减少请求，我们在后续将使用在服务端定时获取数据编译前端模板，然后生成静态文件推送到CDN的方式来改进，和之前的由后端开发同学套模板生成静态文件不同的是，我们将自己搭建这样的中间层服务，在服务端编译前端模板，实现前后端同构，而前端可以随时切换渲染方式，改成请求渲染好的 HTML 字符串来进行加载，以此来提升性能。 对性能优化的探索性能永远是前端工程师追求的主题，过去首页在性能优化上已经做得非常极致了，它已经使用了各种手段来优化性能，包括首屏直出、样式直出来提升首屏速度，楼层按需加载，减少不必要的请求等等，所以在做新版首页的时候，我们感觉战战兢兢，因为改版不能让页面受到影响，而且最好还能比原来更快，所以，这次改版中我们主要通过如下手段来进行性能的优化。 首屏直出和精简首屏直出是让首屏速度更快的最佳选择，此次版本依然选择了首屏直出的方式，直出的内容包括首屏HTML，页面楼层骨架，以及样式和一些必须的脚本，看起来和之前的方式如出一辙，但此次改版我们还是做了很大的改进，那就是让首屏更加精简。 过去是将页面引用的所有样式都直出在页面上，没有外链的CSS，各种优化手段都考虑进去了，那么新版首页就只能在精简大小上下功夫了，所以新版首页的首屏只直出了首屏必须的样式，同时只直出一小部分必须的脚本，而非首屏的楼层样式拆分到各自楼层中，和楼层的模板放在一起，按需加载。 通过对Athena工具的改造，我们实现样式、模板的统一抽离这一功能，并且是在项目编译阶段自动实现的，开发者勿需关心。由于Athena统一的项目结构，每一个楼层在我们的项目中对应一个widget的组件，组件包含自己的HTML 、CSS、 JavaScript文件，同时widget的组件是可以继续调用其他widget的组件的，所以在编译时，工具会自动分析所有widget的依赖关系，然后把楼层的模板和所有引用到样式打包到一个文件中。最后在楼层加载的时候去请求这个文件，然后解析加载。这样的抽离工作会在最后的项目编译阶段进行，而进行本地开发预览的时候并不会执行，这样保证了开发的效率。 1234567// https://misc.360buyimg.com/mtd/pc/index/home/rec_tpl.min.jsjsonCallBack_rec_tpl(&#123; dom: '&#123;%var i,clstagPrefix = pageConfig.clstagPrefix + o.staticLogTag;var isWide = pageConfig.compatible &amp;&amp; pageConfig.wideVersion;%&#125;&#123;% var len = o.list.length; len = Math.min(len, 3); %&#125;&#123;% if (len &gt;= 1) &#123; %&#125;&lt;div class=\"grid_c1 rec_inner\"&gt;&lt;ul class=\"rec_list\"&gt;&#123;% for(i = 0; i &lt; len; i++)&#123; %&#125;&#123;% var item = o.list[i]; %&#125;&#123;% var imgUrl = isWide ? item.imgUrl : item.imgUrlB; %&#125;&lt;li class=\"rec_item\" fclog=\"&#123;%= item.clog %&#125;\"&gt;&lt;a href=\"&#123;%= item.url %&#125;\" class=\"rec_lk\" target=\"_blank\" clstag=\"&#123;%= clstagPrefix + \\'a\\' + (i &lt; 9 ? \\'0\\' : \\'\\') + (1+i) %&#125;\"&gt;&lt;img src=\"//misc.360buyimg.com/mtd/pc/common/img/blank.png\" data-lazy-img=\"&#123;%= imgUrl %&#125;\" alt=\"&#123;%= item.title %&#125;\" title=\"&#123;%= item.title %&#125;\" class=\"rec_img\" data-webp=\"no\" &gt;&lt;/a&gt;&lt;/li&gt;&#123;% &#125; %&#125;&lt;/ul&gt;&lt;/div&gt;&#123;% &#125; %&#125; ', style: \".rec_list&#123;overflow:hidden;height:100px&#125;.rec_item&#123;overflow:hidden;float:left;width:396px;height:100%&#125;.rec_lk&#123;display:block;height:100%&#125;.rec_img&#123;display:block;margin:auto&#125;.o2_mini .rec_item&#123;width:330px&#125;.csstransitions .rec_img&#123;-webkit-transition:opacity .2s;-moz-transition:opacity .2s;transition:opacity .2s&#125;.csstransitions .rec_lk:hover .rec_img&#123;opacity:.8&#125;\", time: 1479195351434, version: \"ff78610a0ef9cdbb\"&#125;); 通过上述手段，我们让首屏变得更加精简，从下面的对比中就可以看出 这是过去首页首屏大小 这是新版首页首屏大小 可以看出优化精简之后，新版的首屏的大小减小了非常之多。 首屏轮播第一帧直出一直以来轮播都是靠页面最后加载的JS来进行渲染的，因为轮播图有随机渲染图片的逻辑需要依赖JS，但在一段时间的观察之后发现，如果CDN出现抖动，或者用户的网速较慢，那么首屏轮播这一块位置就会一直空着，给人的体验非常不好 所以在这一版的首页中我们将轮播图第一帧的数据直出在页面上，同时也将第一帧的渲染逻辑也直出在页面上，这样一来，首屏轮播出来得就非常快，减少用户的等待时间。 楼层按需加载与滚动优化首屏直出后，非首屏的内容肯定也不会一次性全部加载，因为像首页这样的页面楼层非常之多，一次性加载全部不仅仅慢，而且对接口来说也是一种损耗，所以我们考虑将楼层按需加载。 在我们新的方案中，已经采用了前端模板+数据的开发模式，所以在开发中我们想用直接书写前端模板的方式来进行开发，然后在本地进行预览，而在项目编译时能将我们的模板编译成独立的文件，方便渲染逻辑进行加载。所幸Athena工具已经支持了这样的功能，在开发中我们以编写前端模板的方式去开发整个页面，随后通过编译工具，在代码编译阶段自动将楼层的模板和样式抽离成一个与组件同名的独立JS文件，通过页面加载逻辑去按需拉取模板文件，再进行渲染。 下面例子揭示了楼层模板生成的过程 直接书写前端模板，编写模板时我们给模板加上标记位 o2-out-tpl1234567891011121314151617181920212223&lt;script type=\"text/template\" class=\"o2template\" o2-out-tpl&gt; &#123;% var i, clstagPrefix = pageConfig.clstagPrefix + o.staticLogTag; var isWide = pageConfig.compatible &amp;&amp; pageConfig.wideVersion; %&#125; &#123;% var len = o.list.length; len = Math.min(len, 3); %&#125; &#123;% if (len &gt;= 1) &#123; %&#125; &lt;div class=\"grid_c1 rec_inner\"&gt; &lt;ul class=\"rec_list\"&gt; &#123;% for(i = 0; i &lt; len; i++)&#123; %&#125; &#123;% var item = o.list[i]; %&#125; &#123;% var imgUrl = isWide ? item.imgUrl : item.imgUrlB; %&#125; &lt;li class=\"rec_item\" fclog=\"&#123;%= item.clog %&#125;\"&gt; &lt;a href=\"&#123;%= item.url %&#125;\" class=\"rec_lk\" target=\"_blank\" clstag=\"&#123;%= clstagPrefix + 'a' + (i &lt; 9 ? '0' : '') + (1+i) %&#125;\"&gt; &lt;img src=\"//misc.360buyimg.com/mtd/pc/common/img/blank.png\" data-lazy-img=\"&#123;%= imgUrl %&#125;\" alt=\"&#123;%= item.title %&#125;\" title=\"&#123;%= item.title %&#125;\" class=\"rec_img\" data-webp=\"no\" &gt; &lt;/a&gt; &lt;/li&gt; &#123;% &#125; %&#125; &lt;/ul&gt; &lt;/div&gt; &#123;% &#125; %&#125;&lt;/script&gt; 在编译时扫描依赖关系，生成模板JS文件依赖组件的关系表1234567891011121314151617181920212223242526272829303132333435\"dependency\": &#123; \"elevator_tpl.js\": [], \"entry_tpl.js\": [ &#123; \"widgetName\": \"spetit\", \"module\": \"home\", \"moduleId\": \"f1c9d790-765a-11e6-927d-63ab47c8eeb2\", \"widgetType\": \"widget\", \"exists\": true &#125; ], \"fbt_tpl.js\": [ &#123; \"widgetName\": \"find\", \"module\": \"home\", \"moduleId\": \"f1c9d790-765a-11e6-927d-63ab47c8eeb2\", \"widgetType\": \"widget\", \"exists\": true &#125;, &#123; \"widgetName\": \"brand\", \"module\": \"home\", \"moduleId\": \"f1c9d790-765a-11e6-927d-63ab47c8eeb2\", \"widgetType\": \"widget\", \"exists\": true &#125;, &#123; \"widgetName\": \"top\", \"module\": \"home\", \"moduleId\": \"f1c9d790-765a-11e6-927d-63ab47c8eeb2\", \"widgetType\": \"widget\", \"exists\": true &#125; ]&#125; 通过关系表去合并处理CSS样式，再和前端模板一起计算出MD5，生成独立的JS文件1jsonCallBack_rec_tpl(&#123;dom:'&#123;%var i,clstagPrefix = pageConfig.clstagPrefix + o.staticLogTag;var isWide = pageConfig.compatible &amp;&amp; pageConfig.wideVersion;%&#125;&#123;% var len = o.list.length; len = Math.min(len, 3); %&#125;&#123;% if (len &gt;= 1) &#123; %&#125;&lt;div class=\"grid_c1 rec_inner\"&gt;&lt;ul class=\"rec_list\"&gt;&#123;% for(i = 0; i &lt; len; i++)&#123; %&#125;&#123;% var item = o.list[i]; %&#125;&#123;% var imgUrl = isWide ? item.imgUrl : item.imgUrlB; %&#125;&lt;li class=\"rec_item\" fclog=\"&#123;%= item.clog %&#125;\"&gt;&lt;a href=\"&#123;%= item.url %&#125;\" class=\"rec_lk\" target=\"_blank\" clstag=\"&#123;%= clstagPrefix + \\'a\\' + (i &lt; 9 ? \\'0\\' : \\'\\') + (1+i) %&#125;\"&gt;&lt;img src=\"//misc.360buyimg.com/mtd/pc/common/img/blank.png\" data-lazy-img=\"&#123;%= imgUrl %&#125;\" alt=\"&#123;%= item.title %&#125;\" title=\"&#123;%= item.title %&#125;\" class=\"rec_img\" data-webp=\"no\" &gt;&lt;/a&gt;&lt;/li&gt;&#123;% &#125; %&#125;&lt;/ul&gt;&lt;/div&gt;&#123;% &#125; %&#125; ',style:\".rec_list&#123;overflow:hidden;height:100px&#125;.rec_item&#123;overflow:hidden;float:left;width:396px;height:100%&#125;.rec_lk&#123;display:block;height:100%&#125;.rec_img&#123;display:block;margin:auto&#125;.o2_mini .rec_item&#123;width:330px&#125;.csstransitions .rec_img&#123;-webkit-transition:opacity .2s;-moz-transition:opacity .2s;transition:opacity .2s&#125;.csstransitions .rec_lk:hover .rec_img&#123;opacity:.8&#125;\",time:1479466862559,version:\"ff78610a0ef9cdbb\"&#125;); 同时会在逻辑脚本入口位置自动加入模板的版本号123456789101112&#123; \"elevator_tpl\": \"e4d5dbaa3ecd12d2\", \"entry_tpl\": \"e3150fce4b2b332a\", \"fbt_tpl\": \"18f8bff18188a453\", \"floor_coupon_tpl\": \"1559694cb962e0d6\", \"floor_ract_tpl\": \"13b92d16fb6e2f7a\", \"mod_footer_tpl\": \"49142394d0e7f24e\", \"more_tpl\": \"d300081dd7f13f78\", \"portal_tpl\": \"68fae801a032cf93\", \"rec_tpl\": \"ff78610a0ef9cdbb\", \"seckill_tpl\": \"f11d04fd7eabc0e6\"&#125; 模板文件通过系统发布到CDN后，我们就需要有一套加载逻辑来进行加载。通过监听滚动事件，我们判断让处于浏览器视窗内的楼层进行加载，由于监听了滚动事件，为了让滚动更加流畅，我们必然要对滚动中做的操作进行优化。为了避免滚动操作不断被触发，需要对滚动进行节流处理。我们的原则是尽量避免在滚动的时候进行DOM操作与复杂计算，所以在渲染逻辑初始化的时候，我们就已经收集好了楼层的相关信息，包括楼层高度、楼层的offsetTop等，这样在滚动的时候就不再需要进行任何DOM操作了，让滚动的效率有所提升。而当楼层的数据例如楼层高度发生变化时，则通过消息通知的机制来实时地更新楼层信息即可。 脚本延后加载执行除了楼层是按需加载的，页面中用到的一些脚本文件也是尽量延后加载、执行。Athena工具在代码打包的时候，会对每个独立的文件进行单独处理，同时生成一份静态资源的线上对应表，在编译的最后会将引用的资源替换成配置的线上绝对地址。我们可以使用Seajs提供的require.asyncAPI来进行异步加载资源，这样让资源加载更加合理。 12345// 开发中的代码require.async(__uri('APP_JS_ROOT/header.js'))// 编译后require.async('//misc.360buyimg.com/mtd/pc/index/js/header.js') 同时，还有业务上一些统计上报等逻辑，可以放到 window onload 事件之后再执行，这样可以避免由于类似统计这样的请求占用到页面加载资源，从而降低页面 onload 时间。 模板、数据分离缓存每个楼层都按需加载之后，每次去加载这个楼层是否都要重新去请求这个楼层的模板和数据呢？答案当然是否定的。 目前大部分浏览器已经提供了许多前端缓存的解决方案，而其中兼容性最好，易用性最强的非localStorage莫属。利用localStorage我们可以对模板和数据进行缓存，这样当用户第二次加载的时候就可以不用再去请求网络资源，而可以直接从本地获取了。 但缓存之后如何进行更新呢？我们可以通过进行MD5校验版本来实现。 对数据来说，数据是由后端给出的，我们可以让后端同学将可以缓存的接口数据计算出一个MD5值作为版本号，然后直出在页面上，同时在接口中返回这个版本号，这样当前端去加载是首先判断版本号是否一致，以此来判断是直接读缓存还是从网络请求资源。 而对于模板来说，则可以通过Athena工具，在每次编译的时候自行计算出版本号，写入模板文件和入口JS文件中，这样在模板加载的时候也可以进行比对。 单个模板文件 1234567// https://misc.360buyimg.com/mtd/pc/index/home/rec_tpl.min.jsjsonCallBack_rec_tpl(&#123; dom: '&#123;%var i,clstagPrefix = pageConfig.clstagPrefix + o.staticLogTag;var isWide = pageConfig.compatible &amp;&amp; pageConfig.wideVersion;%&#125;&#123;% var len = o.list.length; len = Math.min(len, 3); %&#125;&#123;% if (len &gt;= 1) &#123; %&#125;&lt;div class=\"grid_c1 rec_inner\"&gt;&lt;ul class=\"rec_list\"&gt;&#123;% for(i = 0; i &lt; len; i++)&#123; %&#125;&#123;% var item = o.list[i]; %&#125;&#123;% var imgUrl = isWide ? item.imgUrl : item.imgUrlB; %&#125;&lt;li class=\"rec_item\" fclog=\"&#123;%= item.clog %&#125;\"&gt;&lt;a href=\"&#123;%= item.url %&#125;\" class=\"rec_lk\" target=\"_blank\" clstag=\"&#123;%= clstagPrefix + \\'a\\' + (i &lt; 9 ? \\'0\\' : \\'\\') + (1+i) %&#125;\"&gt;&lt;img src=\"//misc.360buyimg.com/mtd/pc/common/img/blank.png\" data-lazy-img=\"&#123;%= imgUrl %&#125;\" alt=\"&#123;%= item.title %&#125;\" title=\"&#123;%= item.title %&#125;\" class=\"rec_img\" data-webp=\"no\" &gt;&lt;/a&gt;&lt;/li&gt;&#123;% &#125; %&#125;&lt;/ul&gt;&lt;/div&gt;&#123;% &#125; %&#125; ', style: \".rec_list&#123;overflow:hidden;height:100px&#125;.rec_item&#123;overflow:hidden;float:left;width:396px;height:100%&#125;.rec_lk&#123;display:block;height:100%&#125;.rec_img&#123;display:block;margin:auto&#125;.o2_mini .rec_item&#123;width:330px&#125;.csstransitions .rec_img&#123;-webkit-transition:opacity .2s;-moz-transition:opacity .2s;transition:opacity .2s&#125;.csstransitions .rec_lk:hover .rec_img&#123;opacity:.8&#125;\", time: 1479195351434, version: \"ff78610a0ef9cdbb\"&#125;); JS入口文件 1234567891011121314// https://misc.360buyimg.com/mtd/pc/index/home/index_focus.min.jswindow.tplVersion = &#123; \"1212_tpl\": \"ce7dcd7cd0beacb2\", elevator_tpl: \"e4d5dbaa3ecd12d2\", entry_tpl: \"2caa7cd543c322ea\", fbt_tpl: \"18f8bff18188a453\", floor_coupon_tpl: \"b98cf33be84aae98\", floor_ract_tpl: \"13b92d16fb6e2f7a\", mod_footer_tpl: \"072072ffc47778be\", more_tpl: \"25dcb060800c503a\", portal_tpl: \"68fae801a032cf93\", rec_tpl: \"ff78610a0ef9cdbb\", seckill_tpl: \"4fee56c5b073e5e1\"&#125;; 通过上述方式，我们实现了模板、数据的分离缓存，由于楼层类似的关系，页面中的模板大多数是重复，这样子模板缓存起来就能大大提高模板的利用率，当用户第二次访问的时候将不会再产生请求，在加速访问的同时，减少网络带宽消耗，并且如果数据发生更新，用户只需要更新数据即可，大大减少流量消耗。 大量使用WebP格式图片在这次改版中，很多的图片我们都使用了WebP格式来减小图片大小。 WebP格式，是谷歌开发的一种旨在加快图片加载速度的图片格式，图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。但WebP的兼容性不太好，目前基本只有Chrome浏览器可以支持，不过这对我们的首页来说，使用WebP还是会有很大的收益，因为通过我们的统计数据可知，首页Chrome用户已经占到了60%左右。 体验优化探索在努力提升页面性能的同时，还要让页面的用户体验有所提升，这需要我们能站在用户和前端的角度提出合理的优化方案。 高清屏适配方案人类的社会在发展，人类的社会在进步，现如今高清分辨率屏幕的应用已经越来越多，高冷的Mac自不必说，现在许多新型号的Windows电脑也配备了高清分辨率的显示器，所以为了提升这一部分用户的浏览体验，我们需要在高清屏上启用高清素材。 但页面中素材图基本都是运营上传的，如果传两套图对运营来说未免太过麻烦，但如果只传一套高清图，直接展示的话对非高清屏没有必要，会造成流量损耗。这时候京东给力的图片服务就发挥作用了。 图片服务支持按一定规则改变URL来等比缩放图片，例如原图是一张800X340的图片 1//img13.360buyimg.com/cms/jfs/t3412/357/1332248120/113691/f29c2f1e/58244d4dN08b89f9e.jpg!q90.webp 我们可以通过这样设置来得到一样等比缩放400X170的图片 1//img13.360buyimg.com/cms/s400x170_jfs/t3412/357/1332248120/113691/f29c2f1e/58244d4dN08b89f9e.jpg!q90.webp 这样的话，运营同学只需要上传一张高清图片，我们通过判断是否高清屏，来动态改变URL，使用图片服务来得到一张等比缩放的非高清素材，而且CDN会根据图片URL进行缓存，也就是说只要第一次访问过缩放的图片就好，这样性能也不会有什么损耗。 强制webkit内核渲染很多国产浏览器都是双内核，例如360、QQ浏览器等，而它们都提供了强制使用Webkit内核渲染的开启方式，这样可以让用户获得更好的浏览体验。 1&lt;meta name=\"renderer\" content=\"webkit\" /&gt; OpenSearch现在很多网站都能实现在浏览器搜索框内直接调用网站内部搜索的功能，这是通过 OpenSearch 来做到的，而京东之前一直是没有的，这样显然是不合适，而且有一些习惯于使用地址栏搜索的用户不能满足。在这次改版中，我们加上了这一功能，使得用户可以在浏览器地址栏就能直达京东搜索。 使用Icon Font使用Icon Font可以提升设计师的发挥空间，在页面上使用一些特殊字体以提升页面的美观程度，让页面看起来更具有设计感，更加细腻，从而提升用户的浏览体验。 而且Icon Font兼容性非常好，可以让不同浏览器的用户获得一致的浏览体验，并且通过字体压缩工具，压缩后的字体文件也可以非常小，不会有太多的性能损耗。 空闲时间自动加载楼层及图片前文提到，我们使用了按需加载来提升页面性能，但这样带来的问题就是只有当用户滚动楼层到浏览器视窗内，楼层才会开始加载，这样用户滚动得稍微快一点就会出现很多loading动画。 为了减少这种情况的发生，让用户觉得楼层也加载很快，在不影响页面滚动、加载性能的前提下我们在用户操作的空闲时间自动加载剩余的楼层和图片。 将楼层的加载操作放入一个队列中，我们可以在用户停止滚动操作3s后开始自动加载这个队列中的楼层，而当用户开始滚动的时候清空这个加载队列，停止滚动3秒后又重新开始加载。通过这样处理可以合理利用用户浏览的空闲时间来加载页面，让用户感觉页面加载更快。 123456789101112131415161718192021var scrollTimer = null;var isScrolling = false;$(window).bind('scroll.loadFloor', function (e) &#123; isScrolling = true; clearTimeout(autoLoadTimer); clearTimeout(scrollTimer); autoLoadingQueue = []; resourceLoader &amp;&amp; resourceLoader.pause(); scrollTimer = setTimeout(function () &#123; isScrolling = false; if (pageConfig.idleTimeLoad) &#123; autoLoadTimer = setTimeout(autoLoad, 3000); &#125; &#125;, 200);&#125;);function autoLoad () &#123; if (!isScrolling) &#123; runFloorLoadQueue(); &#125;&#125; 页面可用性保障和监控灾备策略对于像京东首页这种大流量的网站，后端接口可能偶尔会出现错误，或者直接挂掉，特别是在双11这种可能会达到流量峰值的时候，但是不能因为接口出错的原因而使得页面显示出现错误。这就需要前端来配合给出一套合理的灾备方案。 通常，我们通过接口缓存、超时、重试来进行灾备处理。目前首页大部分接口、及所有模板请求，在请求成功后都会存入本地缓存，第二次请求，假如缓存没有过期将直接使用缓存，假如缓存过期将会重新请求，而一次正常的请求，都会经过超时或异常重试的逻辑，来保证用户能尽量访问到正常的数据，在正常接口无法获取数据之后又会有兜底接口来保障数据来源，这样的层层保障，很好地保证了页面的完整性。而且，针对所有接口，前端均有数据校验逻辑，每一个后端接口都要经过前端的数据校验，来验证接口的可用性，假如接口数据异常，前端将主动调用兜底接口来替代，这样来保证页面不至于错乱。 综上所述，首页的接口和模板正常请求流程如下 这样一套复杂的流程下，每一个接口、模板请求都是统一的，所以需要对此进行封装，以便调用。首页是通过封装改造$.ajax来实现的，使用$.ajaxPrefilter和$.ajaxTransport方法对每个异步请求进行捕获处理，将接口、模板请求的重试、超时、缓存、兜底调用等封装起来，对调用者透明，使用起来变得非常容易，而不需要关心以上灾备策略的实现。 123456789101112131415161718var ajax = require('load_async');// 本质就是$.ajax方法ajax(&#123; url: '//f.3.cn/index-floor/?argv=aggr', jsonpCallback: 'jsonpCallbakcAggr', // jsonp回调函数名 params: &#123;&#125;, // 参数 needStore: true, // 是否需要缓存 storeSign: '3aad2efsdf', //用户判断缓存是否过期的标记 timeout: 3000, //接口超时 times: 2, // 超时重试次数 backup: '//www.3.cn/bak/aggr', // 兜底接口 dataCheck: function (result) &#123; // 接口数据校验，校验接口返回数据，若为true则走正常逻辑，为false则自动调用兜底逻辑 if (result &amp;&amp; result.code === 0) &#123; return true; &#125; return false; &#125;&#125;); 数据统计驱动改进在这次首页改版项目中我们接入了Athena测速系统用于收集首页各种性能以及用户环境相关的数据，因为有了数据统计，我们才能知道用户端具体的情况信息，有了数据统计，我们才能对页面进行实时监控，有了数据统计，我们才能掌握我们做性能优化的成果，所有的分析都是要基于数据来进行，否则就是在自己在YY了。 目前我们主要收集了，用户网速、操作系统、浏览器分布、分辨率分布等各种信息，同时对于页面加载情况也有一定的监控，如页面测速打点上报、数据接口出现调用兜底接口的情况上报、楼层接口失败导致楼层隐藏的情况上报等。 通过以上数据统计，我们可以灵活地对我们的页面进行优化，同时及时发现问题，避免损失。例如我们通过统计发现用户在网速低于一定值时页面楼层隐藏数增多，这样我们就可以通过设置更长的超时时间来减少这一情况的发生，还有就是假如某时刻开始发现某接口调用兜底请求数暴增，可以判定接口出现问题而及时反馈给后端同学。 更长远的探索新版首页已经上线小一个月了，表现一直还算良好，我们做出的性能以及体验优化也得到了体现，在此基础上，我们思考了更多的可以做的工作，来提升首页的表现。 静态资源预加载首页承载着许多页面的入口，如频道页还有活动页，在双11的时候，首页会有很多直达活动的入口，如果我们能在首页预加载某些重要的活动页面的资源的话，当用户去访问这些活动页面就能更加迅速地打开浏览了。 架构升级jQuery + Seajs或许让人感到老旧且沮丧，我们考虑在首页上渐渐使用一些新的技术，例如去Seajs化，提供更优的打包方式，让页面性能进一步提升。 中间层探索目前首页虽然差不多实现了前后端分离，但是首屏这里前后端依然存在耦合，假如前端可以介入到中间层的开发，那问题就迎刃而解了，接入中间层后，我们还可以将页面部分楼层做服务端渲染，以减少前端渲染的性能损耗，可以在实现前后端分离的基础上，让页面性能更好，还是有一定意义的。","pubDate":"Mon, 26 Dec 2016 12:25:57 GMT","guid":"https://aotu.io/notes/2016/12/26/jd-index-2016-summary/","category":"项目总结"},{"title":"vim给代码行尾加分号的几种方法","link":"https://aotu.io/notes/2016/12/08/vim-4/","description":"给下面的代码每一行行尾加入分号，有几种方法呢？123var foo = 'aotu'var bar = 'is a team'var foobar = foo + bar","pubDate":"Thu, 08 Dec 2016 02:25:35 GMT","guid":"https://aotu.io/notes/2016/12/08/vim-4/","category":"Web开发"},{"title":"正则表达式实践篇","link":"https://aotu.io/notes/2016/12/07/regexp-practice/","description":"简单的练习：题目 与搜索字符串开始处的 3 个数字匹配。 与除 a、b 和 c 以外的任何字符匹配。 &#39;1234567&#39;.match(/\\d{1,3}/g)的结果。 不以“th”开头的单词匹配。 对密码应用以下限制：其长度必须介于 4 到 8 个字符之间，并且必须至少包含一个数字。 匹配一个中文字符。 答案 与搜索字符串开始处的 3 个数字匹配：/^\\d{3}/。 与除 a、b 和 c 以外的任何字符匹配： /[^abc]/。 ‘1234567’.match(/\\d{1,3}/g)，根据贪婪原则，结果是 [&quot;123&quot;, &quot;456&quot;, &quot;7&quot;]。 不以“th”开头的单词匹配：/\\b(?!th)\\w+\\b/ 。 对密码应用以下限制：其长度必须介于 4 到 8 个字符之间，并且必须至少包含一个数字： /^(?=.*\\d).{4,8}$/ 。首先.{4,8} 表示与包含 4-8 个字符的字符串匹配；然后.*表示单个字符（除换行符 \\n 外）零次或多次，且后面跟着一个数字，注意(?=)只匹配一个位置。 匹配一个中文字符：/[\\u4e00-\\u9fa5]/。 当然，可能答案不唯一，不必较真啦~ 主要目的是回忆熟悉一下语法~如果还不了解正则，可以前往正则表达式理论篇 了解哇~ 真正的实践来了要想在复杂性和完整性之间取得平衡，一个重要因素是要了解将要搜索的文本。好的正则表达式： 只匹配期望的文本，排除不期望的文本； 易于控制和理解； 保证效率。 有时候处理各种极端情况会降低成本/收益的比例。所以某些情况下，不完全依赖正则表达式完成全部工作，比如某些字段用子表达式()括起来，让内存记忆下来，然后再用其他程序来验证。 不过本文还是从学习正则的角度出发，全部依赖正则表达式来写的哇~~ 匹配美元正则表达式：/^\\$[0-9]+(\\.[0-9][0-9])?$/。 分为四部分： ^\\$ 以美元符号开头。 [0-9]+ 至少包含一个数字。 (\\.[0-9][0-9])? 由一个点和两位数组成，匹配0次或1次，因为可能是整数或者是小数。 $ 最后的$表示以数字结尾的。 缺点：不能匹配$1,000 匹配24小时制的时间，比如 09:59 小时部分 方法一：分类逻辑为第一个数字(0、1、2)，可以分为三部分：上午 00点到09点（0可选）；白天10到19点；晚上20到23点。 因此有三个多选分支，得到的结果为： 10?[0-9]|1[0-9]|2[0-3] 还可以优化一下，合并前面的两个多选分支，得到： 1[01]?[0-9]|2[0-3] 方法二：分类逻辑为第二个数字，可以分为两部分：[0-3]和[4-9]。为什么这么分？看看下面这个图就知道了，[0-3]多了一行（以2为第一个数字）： 因此有两个多选分支，结果为：1[012]?[0-3]|[01]?[4-9] 分钟部分 分钟数比较简单，第一个数范围在0-5之间，第二个数在0-9之间，因此得到分钟数为: 1[0-5][0-9] 最后的结果： 小时部分用(?:)包起来，起到一个分组的作用，且不保存匹配项；冒号、分钟数拼起来；最后加上一个分界\\b表示单词的开始或结束，得到最终的结果： 123/\\b(?:[01]?[0-9]|2[0-3]):[0-5][0-9]\\b/// 或者/\\b(?:[012]?[0-3]|[01]?[4-9]):[0-5][0-9]\\b/ 验证： 123var reg = /\\b(?:[01]?[0-9]|2[0-3]):[0-5][0-9]\\b/;'现在是09:49点'.match(reg); // [\"09:49\"]'现在是009:490点'.match(reg); // null 其实这个结果不能说完全正确，首先你要明白这个正则用在什么地方，比如是数据验证或者复杂的字符串搜寻替换。 情景一：填写表单中的字符串必须为24小时制的时间，那么可能第一个\\b需要改成^，第二个\\b改成$。 情景二：用于复杂的字符串搜寻替换时，可能也会匹配这样子的字符串如’跑步用时19:50’,明显的，’19:50’表示19分50秒，而不是表示24小时制的时间19点50分。 匹配IP地址IP地址的规则：点号分开的四个字段，每个字段在0-255之间。 第一步： 如果一个字段是一个数或两个数，肯定是在0-255的范围内的；如果三位数，那么以0或者1开头的三位数也是合法的，即000-199。 从上面的陈述中我们就可以得到三个多选分支： 1\\d|\\d\\d|[01]\\d\\d 我们稍微合并一下这三个多选分支，得到： 1[01]?\\d\\d? 第二步： 我们再来看以2开头的三位数： 第二位数小于5的时候，第三位数范围[0-9]都可以；第二位数等于5的时候，第三位数范围[0-5] ，因此得到两个多选分支： 12[0-4]\\d|25[0-5] 第三步： 前两步合并起来，得到一个字段0-255的表示方法： 1[01]?\\d\\d?|2[0-4]\\d|25[0-5] 第四步： 四个字段合并起来，IP地址正则如下： 1/^(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])$/ 点号要转义一下，^和$需要加上，否则可能匹配52123.3.22.993，因为其中的123.3.22.99是符合的。(?:)起到分组的作用，且不保存匹配项。 一些测试结果： 123456var reg = /^(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])$/;'123.11.22.33.44'.match(reg); // null'52123.3.22.993'.match(reg); // null'123.11.22.33'.match(reg); // [\"123.11.22.33\"]'0.0.0.0'.match(reg); // [\"0.0.0.0\"] 虽然0.0.0.0是合法的，但它是非法的IP地址，使用正则的否定顺序环视功能(零宽负向先行断言)，可加上(?!0+.0+.0+.0+$) ： 1234var reg = /^(?!0+.0+.0+.0+$)(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.(?:[01]?\\d\\d?|2[0-4]\\d|25[0-5])$/;'123.11.22.33'.match(reg); // [\"123.11.22.33\"]'0.0.0.0'.match(reg); // null 匹配分隔符之内的文本常见的匹配要求 匹配/*和*/之间的css注释。 匹配引文字符串””，且容许其中包含转义的引号\\”。 匹配一个HTML tag，也就是尖括号之内的文本，例如。 匹配思路的步骤 匹配起始分隔符。 匹配正文（即结束分隔符之前的所有文本）。 匹配结束分隔符。 容许引文字符串中出现转义引号大概思路描述：起始分隔符和结束分隔符都是&quot;,且正文中容许出现转义之后的引号\\&quot;。 简单情况分析： 举例：匹配类似 I &quot;start \\&quot;x3\\&quot; end&quot; U 文本的 &quot;start \\&quot;x3\\&quot; end&quot; 引文字符串，注意\\&quot;属于转义引号。 起始分隔符和结束分隔符都是&quot;。 字符不是引号，肯定是正文。即[^&quot;]表示不是引号的其他任意字符。 引号&quot;前面有反斜线\\，且被反斜线\\转义，则也属于正文。例如start\\&quot;引号的前面有一个反斜线，那么这个引号也属于正文。即(?&lt;=\\)”表示匹配一个引号，它的前面有一个\\，注意正则的反斜线也要用\\来转义一下,因为\\是特殊字符。 用非捕获分组(?:)将[^&quot;]|(?&lt;=\\\\)&quot;括起来，给个量词*，表示匹配正文0次或多次。因此可以写出正则表达式： /&quot;(?:[^&quot;]|(?&lt;=\\\\)&quot;)*&quot;/注意：ES7才支持逆序环视(?&lt;=) 验证1：验证正则：/&quot;(?:[^&quot;]|(?&lt;=\\\\)&quot;)*&quot;/ 12345'I \"start \\\"x3\\\" end\" U'.match(/\"(?:[^\"]|(?&lt;=\\\\)\")*\"/);// 结果： [\"\"start \"\"]'I \"start \\\\\"x3\\\\\" end\" U'.match(/\"(?:[^\"]|(?&lt;=\\\\)\")*\"/);// 结果：[\"\"start \\\"x3\\\" end\"\"] 为什么第2个才是对的呢？我们看一下返回的input属性就了解了： 验证2：验证正则：/&quot;(?:[^&quot;]|(?&lt;=\\\\)&quot;)*&quot;/ 1234'I \"start \\\\\"x3\\\\\\\\\" end\" U'.match(/\"(?:[^\"]|(?&lt;=\\\\)\")*\"/);// 结果与期望不符合：[\"\"start \\\"x3\\\\\" end\"\"]// 期望：[\"\"start\\\"x3\\\\\"]// 注意返回的input属性为：\"I \"start \\\"x3\\\\\" end\" U\" 引号”前面有反斜线\\，但是这个反斜线不是转义引号的，那么引号就不应该属于正文，而是属于结束分隔符。什么情况反斜线\\不转义引号呢？这个反斜线\\本身就是被转义的情况。 上面的结果按照预期结果应该返回 [&quot;&quot;start\\&quot;x3\\\\&quot;]，但是现在多了end&quot;。因此验证这个正则表达式不正确。 也就是说，正文中可出现转义的字符，因此得出正则\\\\. ，注意第一个\\表示转义第二个\\,点表示匹配除换行符 \\n 之外的任何单个字符）,例如可以匹配\\+或者\\\\。而且转义的字符已经包含了\\&quot;的情况，因此正则(?&lt;=\\\\)&quot;可以不用写了，且替换成\\\\.。 因此改正后的正则：/&quot;(?:\\\\.|[^&quot;])*&quot;/ 你可能注意到了，我把[^”]和\\.的位置调换一下，后面的验证3会讲到为什么要这么做。 验证3：验证正则：/&quot;(?:\\\\.|[^&quot;])*&quot;/ 和 /&quot;(?:[^&quot;]|\\\\.)*&quot;/ 123456789'I \"start \\\\\"x3\\\\\\\\\" end\" U'.match(/\"(?:\\\\.|[^\"])*\"/);// 结果与期望符合：[\"\"start \\\"x3\\\\\"\"]// input: \"I \"start \\\"x3\\\\\" end\" U\"// [^\"]和\\\\.的位置调换'I \"start \\\\\"x3\\\\\\\\\" end\" U'.match(/\"(?:[^\"]|\\\\.)*\"/);// 结果与期望不符合：[\"\"start \\\"\"]// 期望：[\"\"start\\\"x3\\\\\"]// input: \"I \"start \\\"x3\\\\\" end\" U\" [^&quot;]和\\\\.的位置调换后，结果与期望不符合。那是因为[^&quot;]匹配start \\后，遇到紧接着的&quot;不匹配，交给后面的多选分支\\\\.，也不匹配，又刚好结束分隔符是&quot;,导致匹配成功，结束匹配。 因此两个正则之间 正确的正则是 /&quot;(?:\\\\.|[^&quot;])*&quot;/ 验证4：验证：/&quot;(?:\\\\.|[^&quot;])*&quot;/ 1234'I \"start \\\\\"x3\\\\\" end U'.match(/\"(?:\\\\.|[^\"])*\"/);// 结果与期望不符合：[\"\"start \\\"x3\\\"\"]// 注意end后面少了\",期望结果是null，不匹配// input: \"I \"start \\\"x3\\\" end U\" 上面的字符串 &quot;start\\&quot;x3\\&quot; 其实是没有结束分隔符的，但是还是匹配了。那是因为正则[^&quot;]和\\\\. 一起作用,导致匹配到了文本U末尾，后续想找结束分隔符的时候，结果却找不到，所以只能回溯文本去找结束分隔符，最后找到了 x3\\后面的引号，匹配成功，结束匹配。 回溯会导致不期望的结果，由于是卡在多选分支上出错的，因此猜测多选分支|匹配内容出现重叠。 你想想，如果符合正文的反斜线，不是以[^&quot;]方式匹配,而是以\\\\.的方式匹配，那就不会把好好的\\&quot;拆开来匹配了。 综上所述，一定要让反斜线是以\\\\.的方式匹配，字符串里的反斜杆不能以[^&quot;]方式匹配。因此将[^&quot;]改成[^\\\\&quot;]。这样子就可以确保正确识别正文特殊的\\&quot;和结束分隔符&quot;了。 注意：很多字符在[]都会失去本来的意义，但是反斜杠字符 \\ 仍为转义字符。若要匹配反斜杠字符，请使用两个反斜杠 \\\\。 改正的正则：/&quot;(?:\\\\.|[^\\\\&quot;])*&quot;/ 验证5验证：/&quot;(?:\\\\.|[^\\\\&quot;])*&quot;/ 12345678'I \"start \\\\\"x3\\\\\" end U'.match(/\"(?:\\\\.|[^\\\\\"])*\"/);// 结果与期望符合：null// input: \"I \"start \\\"x3\\\" end\" U\"'I \"start \\\\\"x3\\\\\" end\" U'.match(/\"(?:\\\\.|[^\\\\\"])*\"/);// 结果与期望符合：[\"\"start \\\"x3\\\" end\"\"]// input: \"I \"start \\\"x3\\\" end\" U\" 为了优化，我们可以把[^\\\\&quot;]放在前面，因为普通字符的匹配可能性更大。注意：优化正则提高效率最需要考虑的问题：改动是否会影响匹配。只有在排序与匹配成功无关时才不会影响准确性，才能重新安排多选分支的顺序。 优化后的正则：/&quot;(?:[^\\\\&quot;]|\\\\.)*&quot;/ HTML Tag经历了容许引文字符串中出现转义引号的例子分析，瞬间觉得这个容易了许多。 描述与要求：匹配类似&lt;input name=123 value=&quot;&gt;&quot; &gt;的HTML标签，起始分隔符是&lt;，结束分隔符是&gt;，且HTML 标签属性值中可以出现&gt;。 起始分隔符和结束分隔符都是明确的，我们来分类一下正文。 双引号引用文本 单引号引用文本 除了&gt;和引号之外的任意字符 可能你会当心单双引号引用文本，会像“容许引文字符串中出现转义引号”那么复杂。幸好是HTML Tag的属性值中不允许出现转义引号，因为平常的转义符号\\变成了普通字符。 根据三种情况，分别写出三个正则： &quot;[^&quot;]*&quot; &#39;[^&#39;]*&#39; [^&#39;&quot;&gt;] 好了，用多选分支连起来&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;]，再用非捕获分组(?:)将多选分支括起来，如(?:&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;])，用*表示匹配任意次，最后前后加上开始结束分隔符，搞定： /&lt;(?:&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;])*&gt;/ 验证： 12'&lt;input name=123 value=\"&gt;\" &gt;'.match(/&lt;(?:\"[^\"]*\"|'[^']*'|[^'\"&gt;])*&gt;/)// 结果： [\"&lt;input name=123 value=\"&gt;\" &gt;\"] 体会：看到没有，几乎每个正则都包含多选分支，只要你懂得将数据分类，离成功就不远了。哈哈哈哈哈。 参考《精通正则表达式》http://imweb.io/topic/56e804ef1a5f05dc50643106","pubDate":"Wed, 07 Dec 2016 02:34:01 GMT","guid":"https://aotu.io/notes/2016/12/07/regexp-practice/","category":"Web开发"},{"title":"源码赏析 - 1K的Firewatch游戏","link":"https://aotu.io/notes/2016/12/04/firewatcher-appreciation/","description":"前言讲真，做前端越久，我们就越容易被思维所束缚。比如，应该没几个人会相信用1K代码能够写出一个游戏，而且还是3d的游戏。 在看这段代码之前我们不得不提到一个一年一度的比赛：js1k。每年，主办方会提出一个比赛主题，参赛者们必须围绕这个主题，用1024个字节以内的JS代码做一个参赛作品。比赛的要求有以下几个： Create a fancy pancy JavaScript demo (用JS做出一个华丽的demo) Submissions may be up to 1024 bytes (最多1024字节) Externals are strictly forbidden (禁止引用外部资源) Must work current generation browsers (必须能在现代浏览器中运行) Minification and hacks allowed (允许代码压缩或者hack) 另外，作为基础，demo运行的环境中内置了一部分变量供调用： window.a 是一个canvas元素 window.b 是document.body window.c 是a元素对应的2D/3D上下文 window.d 是document对象 是不是还挺贴心？只需要用一个字母就可以调用原本一长串代码才能拿到的对象喔。 除了这些，比赛还有一些小规则，可以查看比赛的 规则页 ，里面有详细描述，这里就不再多说。 今年比赛的主题是 Let’s get eleMental!，我们今天要看的 Firewatch 就是其中第三位的作品（第一名作品是 Romanesco 2.0 3D分形展示，有强烈的不明觉厉感，建议前往围观；第二名 Voxeling 是一个3D像素Demo）。 Demo介绍游戏通过键盘上下左右+空格键操作。在开始游戏后，面前会有一颗烟花炸开。紧接着烟花下的树开始着火。玩家的任务就是按下空格，用水枪将火扑灭。在一定时间后，树上的火还会点燃周围的树。如果不慎走神，很有可能就救不回这片森林了喔。 源码解析粗略地讲，这份源码总共就分为两个部分： 创建对象 绑定用户交互，进行事件循环 创建对象下面是创建对象部分的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// add treesfor (entities = [playerA = 256]; s = playerX = playerZ = playerA--;) for ( // create trunk entities.push(&#123; c: [i = 12, 60, 30], x: X = Math.sqrt(playerA) * 12 * Math.cos(playerA) + Math.random() * 12, h: 1, y: Y = Math.random() * 3 - 1, z: Z = Math.sqrt(playerA) * 12 * Math.sin(playerA) + Math.random() * 12, s: 2, S: Y * 2 + 16 &#125;); i--; // create leaf entities.push(&#123; c: [150, 60, i * 2], x: X + f * Math.cos(e = Math.random() * 7), z: Z + f * Math.sin(e), h: 860, y: Y - i / 2 + 10, s: 8 &#125;) ) // create fallen fruit f = Math.random() * 7, i % 2 || entities.push(&#123; c: [50, 60, i * 2], x: X + f * Math.cos(e = Math.random() * 7), z: Z + f * Math.sin(e), h: 860, y: -8, s: 1 &#125;);// burn a leaf (doubles as object for active keys)entities[30].p = burn = function (e, f) &#123; // update fire e.h--; e.c = [Math.random() * 60, 100, 0], e.s = Math.random() * 5 + 6, // create smoke / fireworks s % 16 || entities.push(&#123; c: [0, 0, e.w ? -30 : 10], x: e.x + Math.random() * 6, y: e.y, z: e.z, h: 90, v: 60, p: s ? function (e, f) &#123; e.h--; e.y += .5 &#125; : function (e, f) &#123; e.h--; e.c = [Math.random() * 60, 100, 0], e.h &lt; 12 ? e.s += 3 : e.y += 3 &#125;, s: 4 &#125;); // spread fire entities.some(function (f) &#123; return(s % 300 || f.s == 8 &amp;&amp; Math.abs(e.x - f.x) + Math.abs(e.z - f.z) &lt; 40 &amp;&amp; Math.random() * 50 &lt; 1 &amp;&amp; (f.p = burn)) &#125;); e.w = 0&#125;; 为了减少代码占用的空间，作者大量使用了单字母的变量名与属性名，比如entities.c，entities.x等等，代码可读性非常差。 浏览一遍，我们是根本看不出上面这些变量是什么含义了。 但是，我们能够确定的是，这段代码初始化了playerA，playerX，playerZ变量，然后把所有的对象设定好属性后都存入了entities数组中，包括树干，树底下的水果，还有树干等等。没办法，只能先跳过这部分了。 用户交互这是代码中主管用户交互的代码： 123onkeydown = onkeyup = function (e, f) &#123; burn[e.keyCode - 32] = e.type[5]&#125;; 蛤？就这么短？ … 真是这么短。 上面这段代码，看着更像是定义了onkeydown跟onkeyup俩函数，后面理应还有类似于addEventListener之类的语句将这个函数绑定给某个元素某个事件的代码。因为身为前端，我们早已习惯绑定事件的那几种套路： 1234DomEl.addEventListener(eventname, callback); // webkitDomEl.attachEvent(eventname, callback); // IE$.bind(eventname, callback); // jQ// ... 可是任凭老司机怎么 Ctrl+f 搜索代码，也并没有找到所谓的绑定事件的语句。 事实上，作者在定义这两个函数的时候，并没有使用var关键字。意味着，这后面定义的变量，是直接挂在window下的。那么凭空定义的这两个函数，就分别会变成 window.onkeydown 和 window.onkeyup 。没错，这就是我们极度不推崇的绑定回调的方式了。 回调函数的内容，是在用户按下按键的时候将burn中下标为 keyCode - 32 的属性设定为 keydown 或者 keyup 的第六个字母，也就是 w 或者 undefined 。这个做法十分精妙，下面举例说明。 假设我们按下了空格键（keyCode=32），执行 onkeydown 函数，burn[0] = &#39;w&#39;；而放手的时候，则执行 onkeyup 函数， burn[0] = undefined 。这样一来，在事件循环里面只需要判断burn[0]是true还是false，就可以知道空格键按下了没有。同理，burn[5]，burn[6]，burn[7]，burn[8]分别代表了左，上，右，下键的状态。 可是，印象中burn是个函数呀，entities[30].p = burn = function (e, f) {...}，怎么就用来表示按键状态了呢？目的只能有一个，省下一个声明变量的语句。 为了省下多几个字符，程序员真是什么事都做得出来啊… 事件循环终于到了事件循环部分了。这部分代码占了源码大概一半的篇幅。折叠后，代码结构大概是这样的： 结构大概清晰了：首先是玩家的移动，接着是水枪的处理，紧接着是背景天空森林地板的渲染。 每个事件循环一开始，先是移动玩家。1234// move playerplayerA += (!!burn[7] - !!burn[5]) / 20,playerX += (e = !!burn[6] - !!burn[8]) * Math.sin(playerA),playerZ += e * Math.cos(playerA), 理解了用户交互部分的内容，这里就很好理解了。burn[5]与burn[7]分管左右两键，那么playerA很明显就是用户的朝向。而burn[6]与burn[8]分管前后，在经过换算后，我们很快也就能知道playerX与playerZ分别是玩家在x-z平面上的坐标。别忘了这游戏可是3D的，所以并不用x-y坐标系。 接下来是水枪的代码： 1234567891011121314151617181920// discharge waterburn[0] &amp;&amp; entities.push(&#123; c: [200, 60, -5 * Math.sin(s)], x: playerX + 12 * Math.cos(playerA), z: playerZ - 12 * Math.sin(playerA), e: playerA - .5, s: 2, h: 20, p: function (e, f) &#123; e.h--; e.x += 2 * Math.sin(e.e), e.z += 2 * Math.cos(e.e), e.y = 5 - (e.h / 2 - 5) * (e.h / 2 - 5) / 2, entities.some(function (f) &#123; f.p == burn &amp;&amp; Math.abs(e.x - f.x) + Math.abs(e.z - f.z) &lt; e.s / 2 + f.s / 2 &amp;&amp; ( f.h -= f.w = 9 ) &#125;); &#125;&#125;); 只要空格被按下，就会有新的对象被插入entities数组中。不过既然是水枪的代码，我们很容易可以想到，这里插进去的对象正是水流。 水流浇到火上是可以灭火的，所以下面这段带有一堆abs的代码，十有八九是用来判断水流跟火焰的位置关系的。 12345entities.some(function (f) &#123; f.p == burn &amp;&amp; Math.abs(e.x - f.x) + Math.abs(e.z - f.z) &lt; e.s / 2 + f.s / 2 &amp;&amp; ( f.h -= f.w = 9 )&#125;); 后面可以证明我们的猜测并没有错。另外，这段代码最后的&amp;&amp;符号后面的代码，就是灭火的处理函数了。 遍历数组，我们一般是用forEach，而作者在这个例子中全都是用some来做的。我猜作者并没有别的用意，纯粹是因为长度的原因。所以我觉得这里使用map应该更好。 接下来是一些零散的处理。 1234567// prepare canvasc.translate(90, (a.height += 0) / 2 - 120 | 0);// update entitiesentities.some(function (f) &#123; f.p &amp;&amp; f.p(f)&#125;); 首先是平移了画布，其次是遍历对象数组，执行对象的p函数。这样一来就很清晰了。对象的属性p，就是在每个事件循环中处理对象的函数。 1234// draw skyfor (i = 30; i--;) c.fillStyle = 'hsla(' + [160, 60 + '%', 50 + i + '%', 1], c.fillRect(0, i * 4, 320, 4); 接下来，作者巧妙地用循环 + hsla渲染了一个带渐变色的天空。 1234// remove entities no longer neededentities = entities.filter(function (e, f) &#123; return(e.h &gt; 0)&#125;); 这段代码过滤掉了对象数组中h属性不大于0的对象。 回想一下，我们前面看到的每种对象的p函数，都带着h–，而p函数在每个事件循环都会执行。那么这个h属性表示的就是对象的寿命了。这个事件循环的间隔是33ms，也就是30h相当于1秒。 1234567891011121314151617// draw background forestfor (i = 30; i--;) c.fillStyle = 'hsla(' + [160, 60 + '%', 10 + i + '%', 1], c.fillRect(0, 220 - i * 4, 320, 4);// sort entities by distance from the screenentities.some(function (f) &#123; f.Z = (f.x - playerX) * Math.sin(playerA) + (f.z - playerZ) * Math.cos(playerA)&#125;);entities.sort(function (e, f) &#123; return(f.Z - e.Z)&#125;);// draw groundfor (i = 30; i--;) c.fillStyle = 'hsla(' + [10 + 60, 60 + '%', 50 + i + '%', 1], c.fillRect(0, 236 - i * 4, 320, 4); 接下来的这部分，前面的画背景与后面的画地板还是跟前面一样的套路，分别使用循环来绘制带渐变色的森林与地板。可是中间这段是什么鬼？ 根据注释说明，这个部分是将Z属性设置为对象到屏幕的距离，随后做了一次从近到远排序。 至于对象到屏幕的距离如何计算，这里直接画图说明，就不再赘述。 12345678910111213// draw entitiesentities.some(function (f) &#123; !f.v &amp;&amp; f.Z &gt; 160 || f.Z &lt; 8 || Math.abs(e = (f.x - playerX) * Math.cos(playerA) * 160 / f.Z - (f.z - playerZ) * Math.sin(playerA) * 160 / f.Z) &lt; 160 &amp;&amp; ( c.fillStyle = 'hsla(' + [f.c[0], f.c[1] + '%', f.Z / 6 - f.c[2] + 46 + '%', f.S ? 1 : .8], c.fillRect( 160 + e - f.s * 160 / f.Z / 2, 120 - f.y * 160 / f.Z - (f.S || f.s) * 160 / f.Z / 2, f.s * 160 / f.Z, (f.S || f.s) * 160 / f.Z ) )&#125;); 接下来的这段代码就是这个游戏的灵魂所在了。 这是一个遍历entities数组的操作。以 || 符号分割，这个操作可以分为三个部分： !f.v &amp;&amp; f.Z &gt; 160 f.Z &lt; 8 Math.abs(...) &lt; 160 &amp;&amp; (...) 语句1跟2只要有一个成立，语句3就不会被执行。语句1跟2也很好理解，主要是判断对象跟屏幕之间的距离是不是处在(8, 160)的区间内，如果不是就直接跳过该对象。 这里有一个例外情况，在距离大于160的情况下，如果对象带有v属性则还是可以继续后面的判断的。纵观整个代码，带有v属性的只有前面提到的烟雾以及烟花。这就说明烟雾与烟花就算是在160距离开外，依然是可以看到的，事实上也的确如此。 语句3被 &amp;&amp; 符号分割为了两部分： Math.abs(e = (f.x - playerX) * Math.cos(playerA) * 160 / f.Z - (f.z - playerZ) * Math.sin(playerA) * 160 / f.Z) &lt; 160 (c.fillStyle=&#39;...&#39;,c.fillRect(...)) 语句1中的比较，转换为代数式，经过简单的代数变换后，可以变为： dx*cos(α) - dz*sin(α) &lt; f.Z 结合刚刚的图，这个语句意义就是指，线段a需要小于f.Z。而从图上我们可以知道，线段a就是对象投影在屏幕上后与玩家的距离。这样一来，视角90°以外的对象就不会被渲染了。 语句2就是渲染对象的语句了。看到这里的fillStyle函数我们才明白，前面所定义的f.c属性，其实就是定义了对象颜色的hsl值。另外，从fillRect函数的传参情况来看，也很容易看出f.y指的就是对象的y坐标，f.s表示对象的宽高，而f.S则是在绘制树干的时候作为对象的高度来使用。 再回首现在我们对这段代码有大概的理解了，是时候回头看一看了。 首先是创建对象的部分，此处开了两重循环，种下了256课树，每棵树分别有一根树干，12个对象组成的叶子，另外地上有6个果实。 接下来，第30棵树被恶意纵了火（将f.p设置为burn函数），第一棵着火的树还会发出一个烟花作为信号。而由于每一帧最后都有s--语句，这个s被作为一个计数器，让着火的树每16帧发出一个烟圈。 过后，就是熟悉的与用户交互的环节了。这部分已经十分清晰，就不再赘述。 写在最后这段代码虽然短，却是麻雀虽小五脏俱全。实现了游戏的基本功能不说，有一些小细节也是让我大吃一惊。比如树着火时冒出的烟，在普通情况下是深灰色的，而在被水枪浇到的时候，会变成浅灰色；又比如寿命的设定，使树叶在着火之后一段时间会被烧完。 在编程思想上，作者也是很有见地。使用entities数组存储所有对象的信息，给每种对象一个变换函数，这本身就有粒子的思想在其中。此外，setInterval的使用，则是再正常不过的事件循环机制的实现。 编程手法就不用多说了。比如各种利用some函数代替forEach来省字数，又或者是利用burn[e.keyCode - 32] = e.type[5]来判断按键的状态……作者是老司机，这一点是没跑了。 这段代码构思巧妙，思路行云流水…类似的溢美之词说再多也没用。更关键的是，我们干前端这一行的，绝对不只是jQ，选择器，或者node小工具。偶尔看一看别人的代码，还是能够学到很多意想不到的知识的。 参考资料 js1k官网 http://js1k.com js1k规则页 http://js1k.com/2016-elemental/rules Romanesco 2.0 http://js1k.com/2016-elemental/demo/2552 Voxeling http://js1k.com/2016-elemental/demo/2497 Firewatch http://js1k.com/2016-elemental/demo/2512 Firewatch 源码 http://js1k.com/2016-elemental/details/2512","pubDate":"Sun, 04 Dec 2016 15:33:00 GMT","guid":"https://aotu.io/notes/2016/12/04/firewatcher-appreciation/","category":"js1k 游戏 3D"},{"title":"项目心得 -- 京东云改版","link":"https://aotu.io/notes/2016/12/02/jcloud/","description":"2016年即将过去，回顾总结项目的时候，发现日常工作中一些值得我们思考的地方，这次选了印象比较深刻的京东云项目，希望本文能对读者有所帮助，文多图少，一目百行的客官请轻虐。 项目变数由于项目的紧迫性，项目进度基本处于多线并行追赶的状态，产品、视觉、前端三个线边输出边交接，产品和视觉会把重要的框架性的页面先输出给到前端，这样一来，前端得到的交互文档、视觉稿基本是阶段性的，并没有完整的项目逻辑和项目页面可以参考来评估项目的构建方案，项目的公用模块、公用组件、组件管理方式等全局性的内容难以确定，类似这些项目中各种不能确定的信息，我称之为『变数』。『变数』会给构建页面过程带来很多不可预测的问题，这些问题可能会令一部分工作推倒或翻工。 主动获取项目信息面对这种时间线短、各线并行、存在『变数』的项目，主动获取项目信息尤其重要，个人觉得比较重要的有以下几个：项目整体信息结构、整体的时间线规划、视觉稿的具体输出日期、视觉交接 Deadline、前端开发的周期、前端交接 Deadline、项目各线对接负责人。 这次项目属于改版类，从旧版大概了解到站点频道划分、频道之间逻辑关系、业务模块的引用情况等信息，这次改版产品的逻辑变化不大，主要是视觉的优化。虽然前期视觉给到我们的视觉稿只有站点首页，频道的首页和频道的内页都还在并行进行中，但从旧版站点逻辑和产品交互侧得到的信息以及已出的视觉稿可以确定站点哪些部分可以作为公用组件去制作，也可以大致确定项目的资源目录分布。 对于旧站点常见的组件而在已出视觉稿未体现到的，如侧导航弹浮层，找到产品和交互进一步了解后，得知会在频道首页和内页会用到，亦可以确认作为公用组件制作，并可以提前为这些组件制作评估工作量并选择最佳的实现方案。 整体的时间线规划、视觉稿的具体输出日期、视觉交接 Deadline、前端开发的周期以及前端交接 Deadline，这些信息都是项目时间维度上的信息，这类信息的确认，可以让我们更准确评估工作量（在时间线内是否可以完成所有工作），从而在项目紧急性方面做好更合理的人力投入。 潜在『变数』我们接到新项目，一般都会考虑以上的因素，主动去获取项目的信息，这些信息都是显而易见的，但有些信息略显隐蔽。 拿到设计稿的时候，发现视觉设计师只提供了一份 1280 分辨率的宽屏版，国内分辨率使用占比名列前 5 的 1024 分辨率并没有兼容，带着疑问找到视觉确认，得知首页会有 1280 分辨率和 1024 分辨率两个版本，适配 1024 分辨率版本会迟一点给到。 对于这种看似不是问题的问题而前期又可以确认的问题，我是一定要去确认的！这种问题在前期看上去并不会成为项目推进的阻力，但是说不定会在项目后期爆发，对项目造成吨暴击伤害。 记得刚入行的时候就亲身经历过联调阶段调整分辨率兼容问题，产品说『我的笔记本电脑首页出现横向滚动条了』，然后去排查了一下，发现产品用了 1024 分辨率，而视觉给到前端的视觉稿只兼容到 1280 分辨率，当时缺少实际项目经验，就默默按照 1280 去做了。当产品找到视觉，视觉回答『立项的时候文档没有写到分辨率兼容情况呀，所以当时只做了宽屏1280了』，最后产品『还是兼容一下吧，做一个窄版适配吧』，再然后视觉和前端就只能『……』。 这种问题两条线人员很容易懵B『O嘴』，而且最终还是需要重新调整适配 1024 分辨率，视觉和前端两条线都需要额外的工时，而这些工时并不在前期规划内，所以最有可能会令到视觉或前端或两者都加班，如果加班在可控的时间内完成的话还算是亡羊补牢，但如果加班后还是影响到项目进展造成项目 delay 的话，那就不是影响视觉和前端两条工作线工作效率这么简单了，这是一种潜在的『变数』，应该如何避免这种『变数』的出现，非常值得我们去思考。 如果前端可以从立项就开始参与和产品、交互、视觉、开发各线大前期沟通的话，每个岗位的同事都可以就各自的专业去衡量评估项目，是不是能更早地去发现一些潜在的『变数』呢？而去执行实现的话是否需要在流程上做出改动？如果因为团队的合作模式不能实现，作为前端，我们是不是应该更主动去找到各线的同事进行沟通？ 当然，这仅仅是针对此情况而去考虑的东西，其实我想提出的是，面对『项目变数』我们需要做的就是尽可能及时掌握更多关于项目的任何信息去深入了解项目，对项目未来发展作出预见性的判断从而掌握主动权，而不是静静地等待进入前端流程。项目可见度越高，准备越充分，项目主动性越强，只有 100% 的项目信息确认，才能 Kill the 『潜变数』Tens of Thousands Times。 方案推动首页的设计稿包含了很多单色图标，图标复用性很强，同一个图标出现在不同的模块，而且大小又不一样，又需要多态并且兼容 Retina 高清屏。 站在前端角度考虑，PC平台的解决方案，第一时间肯定会想到 iconfont 图标。iconfont 图标已不是什么新鲜的技术，不少同事都在不少项目中都有应用到，可是大家在遇到同一问题使用相同技术的时候，处理方法亦有不同。有的同事可能会自己制作 iconfont 图标；有的同事可能会让设计师提供图标 SVG 文件，利用线上的工具自动生成 iconfont 图标；有的同事可能会把 iconfont 的生成工具介绍给视觉设计师，让视觉设计师生成 iconfont 图标。 站在视觉角度考虑，当然想图标在所以设备都可以高清呈现。不同的设计师经验不一样，有些可能会提供 SVG 文件，有些可能会提供一套1X，2X图，有些甚至会把 3X 图也一起给到前端 当项目同时由多人维护的时候，就可能会出现同一个项目同样的的技术方案出现不一样的协作方式，一旦人员交叉交接的时候，就有意思了。从协作效率上来看是存在一定问题的，因此很有必要让前端和视觉设计师统一一套解决 iconfont 图标的方案。 如何实行？ 个人觉得，最重要的是让大家对问题达成共识，也就是：解决这个问题于工作有何收益？ 首先需要站在视觉方角度让他们知道问题痛点，再提出解决方案并希望得到他们的协作，下面我以对话的形式将当时我和视觉沟通的对话内容简单叙述一下（前端：FE，视觉：VD）： FE：啊宏，这些单色图标数量挺多的呀，复用率又高，很多还有双态，同一个图标还有不一样的尺寸，全部做成图片的话数量很多哇，即使全部合并成 sprite 图，图片的 K 数也会很大呢。最要命的是图标后续不知道还会有多少种色态会扩展，首页还要求适配高清屏呢，这工作量不是一般的小呀。 VD：确实啊，高清屏适配每一个图标我都要给一个 2X 图你，10个图标我就得给你 20 个，如果有双态的话，就得给你40个,这次首页纯色图标就有50个。。。 FE：嗯，会出人命的，主要这些图标都是纯色图标，都做成图片不值得，用 iconfont 图标可以解决，全矢量，还可以用样式控制尺寸大小和颜色，高清屏、尺寸、配色都不是问题呀，省力省时间呢！ VD：666，那这个 iconfont 图标要怎么个搞法啊？我需要做些什么呢？ FE：只需要把图标做成 SVG 文件提供给我就 OK 了呀，网上有 SVG 转 iconfont 图标的服务哈 VD：没问题呀，如果能解决刚才说的问题 FE：是啊是啊！主要是这样处理的话可以节省大家的时间，效率成倍提高的啊，不过生成 iconfont 图标后有些图标会在 windows 显示出问题，有问题的图标需要你用 Ai 再处理一下哟，没问题吧？ VD：没问题啊，总比切一堆图好吧，哈哈~~ FE：好的，那么我们约定好，以后这一类纯色图标我们都统一用 iconfont 图标处理，由视觉这边提供图标的 SVG 文件，然后前端负责生成 iconfont 图标，我会在组内推一下这个处理 iconfont 的流程，麻烦你在视觉组内也推一下这个方法哈，都统一这么处理，看OK么？ VD：好的没问题~~ 6666 ~~~ FE：6666~~ 项目最后一共投入了5个人力完成后期的构建，成功统一使用了这个 iconfont 图片处理流程，避免了一大波 icon 的蹂躏： 痛点定位和效率收益是这次协作成功推动的关键点，个人觉得要成功推动一个方案实施，『痛点』及『收益点』必定是核心点。以上仅仅是一个简单的方案推动例子，真正操作起来也不会太困难，但关键是我们需要从每次的工作收益中沉淀点『好西』出来就很好了。 好了，以上就是我在京东云改版项目中对工作流程以及上下线协作中感受比较深的一些思考和总结。其实问题都很常见，也有很多更好的解决方案，但是要将这些问题和解决方案存在的价值转化出来，还是需要我们做完每一次的项目后认真去总结沉淀，最后，做好业务无非几个字，想得周全，助得快乐，踩得深入，跳得出来。","pubDate":"Fri, 02 Dec 2016 08:26:14 GMT","guid":"https://aotu.io/notes/2016/12/02/jcloud/","category":"项目总结"},{"title":"css3 animation 属性众妙","link":"https://aotu.io/notes/2016/11/28/css3-animation-properties/","description":"本文不会详细介绍每个 css3 animation 属性（需要了解的同学可先移步 MDN），而是结合实际的开发经验，介绍 css3 animation 属性的一些使用场景及技巧。 1. animation-delayMDN 中的介绍： animation-delay CSS 属性定义动画于何时开始，即从动画应用在元素上到动画开始的这段时间的长度。 该属性值默认为 0s，可为正值，也可为负值。 动画时间轴由于 css3 动画没有时间轴，animation-delay 最常见的是用于将动画与其他动画的执行时机错开，将动画落到不同的时间点，形成动画时间轴。12345678910.ani--first &#123; animation-name: aniFirst; animation-duration: 2s; animation-delay: 0s;&#125;.ani--second &#123; animation-name: aniSecond; animation-duration: 1s; animation-delay: 2s; /* aniSecond 延迟 2s 执行*/&#125; 形成的时间轴如下图所示： 轮播css3 animation 亦可实现一些 js 的效果，例如利用 animation-delay 可以实现一个简单的轮播。以下是一个三屏轮播的例子。123456789101112.slider__item &#123; animation: ani 6s infinite linear both; @for $i from 1 to 4 &#123; &amp;:nth-child(#&#123;$i&#125;) &#123; animation-delay: (-1+$i)*2s; &#125; &#125;&#125;@keyframes ani &#123; 0%, 33.33% &#123;opacity: 1; visibility: visible;&#125; 33.34%, 100% &#123;opacity: 0; visibility: hidden;&#125;&#125; See the Pen KNvRxZ by Yetty (@Yetty) on CodePen. 序列动画多个元素使用相同的动画效果时，将动画执行时机依次错开，可形成整齐有序的序列动画效果。12345@for $i from 1 to 6 &#123; .list__item:nth-child(#&#123;$i&#125;) &#123; animation-delay: (-1+$i)*0.1s; /*计算每个元素的 animation-delay */ &#125;&#125; See the Pen listAni by Yetty (@Yetty) on CodePen. 以笔者开发的京东2017海外招聘项目为例，第二屏的菜单和第三屏的时间轴的进退场动画都运用了序列动画。下图展示第三屏时间轴的进场效果，有兴趣的同学亦可扫码观看完整案例。 无限循环的序列动画animation-delay 可为负值。负值会让动画从它的动画序列中某位置立即开始。 巧用这个负值，可以解决实际开发中的一些问题。 如若上述的序列动画要进行无限循环，单纯将 animation-iteration-count 设置为 infinite，动画开始时会有延迟。此时，将 animation-delay 设置为负值，提前动画开始执行的时机，当用户看到动画时，动画便已经处于进行中的状态。12345@for $i from 1 to 6 &#123; .list__item:nth-child(#&#123;$i&#125;) &#123; animation-delay: -$i*0.1s; /* animation-delay 为负值*/ &#125;&#125; See the Pen listAniInfinite by Yetty (@Yetty) on CodePen. 调试动画将 animation-play-state 设置为 paused，animation-delay 设置成不同的负值，可以查看动画在不同帧时的状态，便于进行动画调试。 12345678910111213141516171819.list__item &#123; animation: listAni 0.5s linear both alternate infinite; animation-play-state: paused;&#125;@for $i from 1 to 6 &#123; .list--first .list__item:nth-child(#&#123;$i&#125;) &#123; animation-delay: -$i*0.1s; &#125;&#125;@for $i from 1 to 6 &#123; .list--second .list__item:nth-child(#&#123;$i&#125;) &#123; animation-delay: (-2-$i)*0.1s; &#125;&#125;@for $i from 1 to 6 &#123; .list--third .list__item:nth-child(#&#123;$i&#125;) &#123; animation-delay: (-4-$i)*0.1s; &#125;&#125; See the Pen listAniPaused by Yetty (@Yetty) on CodePen. 2. animation-fill-modeMDN 中的介绍： animation-fill-mode 这个 CSS 属性用来指定在动画执行之前和之后如何给动画的目标应用样式。 animation-fill-mode 应该算是 animation 属性里比较难上手的一个，但它的作用却很大。 保持结束状态“动画结束后，突然跳回第一帧！” 很多刚接触 css3 动画的同学，都是在这个场景下，接触了 animation-fill-mode 属性。将 animation-fill-mode 设置为 forwards，动画执行结束后保持最后一帧的样式。1234.ani-area__item--forwards &#123; animation: ani 1s ease; animation-fill-mode: forwards;&#125; See the Pen MbmvQL by Yetty (@Yetty) on CodePen. 开始前状态开发动画时，我们都是先根据视觉稿做好构建，再来给元素加动画的。如上文所述，可通过 animation-delay 来延迟的动画的执行。而在执行前，元素往往需要先隐藏（translate 定位到视窗外 / opacity 设置为 0 / scale 设置为 0 等）。若将隐藏元素的样式直接应用到元素上，一来不利于构建，二来对于不支持动画的浏览器来说，只会呈现一片空白。此时，animation-fill-mode 的 backwards 属性值便派上用场。 对于 backwards 的解释，笔者见过不少文章的说法都有不妥之处，认为 backwards 与 forwards 相反，表示动画执行结束后保持第一帧的样式。实则不然，我们看下 w3c 的解释： backwards：在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。 换句话说，backwards 作用的是 animation-delay 的时间段，应用第一个关键帧的样式。1234.ani-area__item--backwards &#123; animation: ani 1s 1s ease; animation-fill-mode: backwards;&#125; See the Pen YpVxpw by Yetty (@Yetty) on CodePen. 当然，动画的第一帧和最后一帧的计算还受 animation-direction 和 animation-iteration-count 的影响，MDN 中有详细解释： forwards animation-direction animation-iteration-count last keyframe encountered normal even or odd 100% or to reverse even or odd 0% or from alternate even 0% or from alternate odd 100% or to alternate-reverse even 100% or to alternate-reverse odd 0% or from backwards animation-direction first relevant keyframe normal or alternate 0% or from reverse or alternate-reverse 100% or to 3. animation-direction既然上表中涉及了 animation-direction 属性，那我们就顺着来研究一下它。MDN 中的介绍： animation-direction CSS 属性指示动画是否反向播放。 进/退场动画复用动画元素有进场动画，往往也会需要退场动画。比较常见的做法，退场时使用与进场动画反向的动画。animation-direction 的 reverse 属性值可简单实现反向动画。 先看MDN 中的介绍： reverse：反向运行动画，每周期结束动画由尾到头运行。 1234567891011121314.on &#123; .ani--translate &#123; animation: aniTranslate 1s ease forwards; &#125;&#125;.off &#123; .ani--translate &#123; animation: aniTranslate 1s ease forwards reverse; &#125;&#125;@keyframes aniTranslate &#123; 0% &#123; transform: translateY(300px) &#125; 100% &#123; transform: translateY(0) &#125;&#125; 123$wrap.removeClass('on');$wrap.innerWidth($wrap.innerWidth); /* 使用 reflow 重新触发一下 animation */$wrap.addClass('off'); See the Pen YpQqKZ by Yetty (@Yetty) on CodePen. 当然，上述例子为了演示方便，只是简单做了只有两帧的动画，这种效果用 transition 同样可以实现。 4. animation-play-stateMDN 中的介绍： animation-play-state CSS 属性定义一个动画是否运行或者暂停。 翻页动画控制在做翻页 h5 时，需要对动画的播放进行控制。只有当用户进入当前屏时，动画才开始播放。通常我们会给当前屏加上一个 acitve 类，用来给元素添加动画：123.active .ele &#123; animation: ani 1s ease;&#125; 或者如上文“进/退场动画复用”中的例子，分别用 on 和 off 控制进/退场动画。这都是常见的思路。如果是不需要重复触发的动画，用 animation-play-state 同样可以实现动画的控制。动画属性直接添加到元素上， animation-play-state 默认设置为 paused，当进入当前屏时，将 animation-play-state 设置为 running 即可。1234567.ani &#123; animation: ani1 1s ease; animation-play-state: paused; /* animation-play-state 默认设置为 paused */&#125;.active .ani &#123; animation-play-state: running; /* 进入当前屏，animation-play-state 设置为 running */&#125; See the Pen vymWwE by Yetty (@Yetty) on CodePen. 轮播的交互在前文介绍 animation-delay 时，提到了一个轮播的例子，当用户 hover 时，轮播动画应该暂停，用 animation-play-state 属性便可轻松实现交互：123.slider:hover .slider__item&#123; animation-play-state: paused;&#125; 5. animation-timing-functionMDN 中的介绍： CSS animation-timing-function 属性定义 CSS 动画在每一动画周期中执行的节奏。 关于 animation-timing-function，有一个特别需要注意的点，MDN 中有强调： 对于关键帧动画来说，timing function 作用于一个关键帧周期而非整个动画周期，即从关键帧开始开始，到关键帧结束结束。 也就是说，animation-timing-function 是作用于 @keyframes 中设置的两个关键帧之间的，这一点在该属性值为 steps() 时可明显感知。 逐帧动画animation-timing-function 最让人感到惊（beng）艳（kui）的莫过于 steps() 属性值。利用 steps()，可以轻松实现逐帧动画（又称“精灵动画”），从而告别不可控的 gif 时代。关于逐帧动画，笔者之前在凹凸实验室平台已经发布过相关文章介绍，此处不再赘述，有兴趣的同学可前往围观：《CSS3逐帧动画》。 参考文章： Debugging CSS Keyframe Animations - SARAH DRASNER 多屏复杂动画CSS技巧三则 - zhangxinxu 打造H5动感影集的爱恨情仇(动画性能篇) －TQ","pubDate":"Mon, 28 Nov 2016 02:00:00 GMT","guid":"https://aotu.io/notes/2016/11/28/css3-animation-properties/","category":"Web开发"},{"title":"三看 SVG Web 动效","link":"https://aotu.io/notes/2016/11/22/SVG_Web_Animation/","description":"CSS3 动效玩腻了吗？没关系的，我们还有 SVG。","pubDate":"Tue, 22 Nov 2016 09:33:00 GMT","guid":"https://aotu.io/notes/2016/11/22/SVG_Web_Animation/","category":"Web开发"},{"title":"FIGlet初识","link":"https://aotu.io/notes/2016/11/22/figlet/","description":"FIGlet这个词诂计对于很多前端工程师来说可能比较陌生，但在计算机领域中常常见到。早在十几年前就已经开始有许多利用文字与线条组成的图形，当时甚至用 ASCII 来表示颜色，然而到了今天也被广范使用。","pubDate":"Tue, 22 Nov 2016 09:33:00 GMT","guid":"https://aotu.io/notes/2016/11/22/figlet/","category":"Web开发"},{"title":"「塔罗牌」 - 轻氧 V1.4 尝鲜体验邀请","link":"https://aotu.io/notes/2016/11/21/liteo2-app-tarots/","description":"今天要介绍的是轻氧1.4版本，Code Name「塔罗牌」，这是一个玩儿的版本。 如果你还不知道轻氧是什么鬼，那末可以先移步这里：轻氧 - 2016年末最新款互联网专业资讯 APP，或者直接关注「凹凸实验室」的公众号以获取更多轻氧APP的最新讯息。 在轻氧上一个版本（响尾蛇）推出的时候，我们在实验室的公众号做了一次小范围的推广，总用户数虽然谈不上惊喜，但也超出了一开始的期望，且每日俱增。 朋友们所给的评论和意见，不管褒贬我们都有记录，而其中呼声最高的安卓版本，我们已优先列入开发计划，技术选型上我们决定尝试使用阿里的weex，支持国货，人人有责。 塔罗牌（Tarots)「看看资讯，玩玩牌」，我们其实就是想给「轻氧」加一个神秘好玩的功能，类似远古时代的「占卜」，通过用户主动给予它的一些交互引出一些未知的功能，这个版本叫「塔罗牌」，打开APP，相信你们就知道怎么玩。 玩法实在不会玩的童鞋可以看下玩法流程： APP将玩法最终呈现给用户的是一张张卡片UI，所以我们把每次推送给用户的活动称为「卡牌」。每个卡牌具有不一样的玩法功能和营销意义。 卡牌的出现可以增加一些有趣的逻辑，例如带频道限制的卡牌 - 适用于在不同频道摇出不同的卡片；带时间段限制的卡片 - 可以在不同的时间段、节日摇出不一样的卡片。。。 而至于卡牌内容的设计，嘿嘿，我们可以很乖巧，也可以很邪恶，可以很文艺清新，也可以风骚YD，可以很地方随意，也可以很官方严肃，总之我们努力满足各方要求，不管你是宅男还是欲女！ 在1.4.0版本中，我们只准备了有限的3张卡牌，大伙儿先提前尝尝鲜吧。 成熟性感与完美，需要多给我们一点调教的时间。 尝鲜下载体验 目前仅提供ios版本基于 Weex 的 Android 版与网页版正在紧急开发中，敬请期待。 官网地址：https://app.aotu.io 下载地址： 扫二维码： 问题反馈： 「凹凸实验室」公众号 (AOTULabs) APP 个人中心 -&gt; 设置 -&gt; 意见反馈 希望在这个信息爆炸的时代，「轻氧」能够帮助你聚焦更优质的资讯内容。也让你更加专注于用心被创造出来的文章，和其创造者。","pubDate":"Mon, 21 Nov 2016 05:21:43 GMT","guid":"https://aotu.io/notes/2016/11/21/liteo2-app-tarots/","category":"移动开发"},{"title":"正则表达式理论篇","link":"https://aotu.io/notes/2016/11/17/regexp-theory/","description":"学习正则表达式的你们，有没有发现，一开始总是记不住语法。嗯，加深大家的印象的同时，我也是来找同道中人的。","pubDate":"Thu, 17 Nov 2016 01:29:38 GMT","guid":"https://aotu.io/notes/2016/11/17/regexp-theory/","category":"Web开发"},{"title":"XCel 项目总结 - Electron 与 Vue 的性能优化","link":"https://aotu.io/notes/2016/11/15/xcel/","description":"XCEL 是由京东用户体验设计部凹凸实验室推出的一个 Excel 数据清洗工具，其通过可视化的方式让用户轻松地对 Excel 数据进行筛选。 XCEL 基于 Electron 和 Vue 2.0 进行开发，充分利用 Electron 多进程任务处理等功能，使其拥有高性能、跨平台（windows 7+、Mac 和 Linux）的特性。 落地页：https://xcel.aotu.io/ ✨✨✨项目地址：https://github.com/o2team/xcel ✨✨✨ 项目背景用户研究的定量研究和轻量级数据处理中，均需对数据进行清洗处理，用以剔除异常数据，保证数据结果的信度和效度。目前因调研数据和轻量级数据的多变性，对轻量级数据清洗往往采取人工清洗，缺少统一、标准的清洗流程，但对于调研和轻量级的数据往往是需要保证数据稳定性的，因此，在对数据进行清洗的时候最好有可以标准化的清洗方式。 特性一览 基于 Electron 研发并打包成为原生应用，用户体验良好； 可视化操作 Excel 数据，支持文件的导入导出； 拥有单列运算逻辑、多列运算逻辑和双列范围逻辑三种筛选方式，并且可通过“且”、“或”和“编组”的方式任意组合。 思路与实现结合用研组的需求，我们利用 Electron 和 Vue 的特性对该工具进行开发。 技术选型 Electron：桌面端跨平台框架，为 Web 提供了原生接口的权限。打包后的程序兼容 Windows 7 及以上、Mac、Linux 的 32 / 64 位系统。详情&gt;&gt; Vue 全家桶：Vue 拥有数据驱动视图的特性，适合重数据交互的应用。详情&gt;&gt; js-xlsx：各种电子表格格式的解析器和生成器。纯 JavaScript 实现，适用于 Node.js 和 Web 前端。详情&gt;&gt; 实现思路 通过 js-xlsx 解析 Excel 文件生成 JSON 格式 根据筛选条件对 JSON 数据进行筛选过滤 将过滤后的 JSON 数据生成 js-xlsx 指定的数据结构 利用 js-xlsx 对转换后的数据生成 Excel 文件 纸上得来终觉浅，绝知此事要躬行 相关技术如果对某项技术比较熟悉可略读/跳过。 ElectronElectron 是什么？Electron 是一个能让你通过 JavaScript、HTML 和 CSS 构建桌面应用的框架。这些应用能打包到 Mac、Windows 和 Linux 电脑上运行，当然它们也能上架到 Mac 和 Windows 的 app stores。 JavaScript、HTML 和 CSS 都是 Web 语言，这就意味着它们都是组成网站的一部分，浏览器（如 Chrome）能将这些代码转为可视化图像。 Electron 是一个框架：Electron 对底层代码进行抽象和封装，让开发者能在此之上构建项目。 为什么它如此重要？通常来说，桌面应用都需要用每个操作系统对应的原生语言进行开发。这意味着需要拥有 3 个团队为这个应用编写 3 个相应的版本。Electron 则允许你通过 web 语言编写一次即可。 原生（操作系统）语言：用于开发主流操作系统的应用的原生语言如下（大多数情况下）：Mac 对应 Objective C、Linux 对应 C、Windows 对应 C++。 它由什么组成？Electron 结合了 Chromium、Node.js 和用于调用操作系统本地功能的 API（如打开文件窗口、通知、图标等）。 Chromium：Google 创造的一个开源库，并用于 Google 的浏览器 Chrome。 Node.js（Node）：一个用于在服务器运行 JavaScript 的运行时（runtime），它拥有文件系统和网络的权限（你的电脑也可以是一台服务器！）。 开发体验如何？基于 Electron 的开发，就好像开发一个网页一样，而且能够无缝地 使用 Node。或者说：就好像构建一个 Node app，并通过 HTML 和 CSS 构建界面。另外，你只需为一个浏览器（最新的 Chrome）进行设计（即无需考虑兼容性）。 使用内置的 Node：这还不是全部！除了 Node API，你还可以使用托管在 npm 上，超过 350,000 个的模块。 一个浏览器：并非所有浏览器都提供一致的样式，因此 web 设计师和开发者时常不得不花费更多的精力去让一个网站在不同的浏览器上看起来一致。 最新的 Chrome：可使用超过 90% 的 ES2015 特性和其它很酷的特性（如 CSS 变量）。 两个进程（重点）Electron 有两个种进程：『主进程』和『渲染进程』。有些模块只能工作在其中一个进程上，而有些则能工作在两个进程上。主进程更多地充当幕后角色，而渲染进程则是应用的每个窗口。PS：可通过任务管理器（PC）/活动监视器（Mac）查看进程的相关信息。 模块：Electron 的 API 是根据它们的功能进行分组。例如：dialog 模块拥有所有原生 dialog 的 API，如打开文件、保存文件和弹窗。 主进程主进程，通常是一个命名为 main.js 的文件，该文件是每个 Electron 应用的入口。它控制了应用的生命周期（从打开到关闭）。它能调用原生元素和创建新的（多个）渲染进程，而且整个 Node API 是内置其中的。 调用原生元素：打开 diglog 和其它操作系统交互均是资源密集型操作（注：出于安全考虑，渲染进程是不能直接调用本地资源的），因此都需要在主进程完成。 渲染进程渲染进程是应用的一个浏览器窗口。与主进程不同，它能存在多个（注：一个 Electron 应用只能有一个主进程）并且是相互独立的。它们也能是隐藏的。它通常被命名为 index.html。它们就像典型的 HTML 文件，但在 Electron 中，它们能获取完整的 Node API 特性。因此，这也是它与其它浏览器不同的地方。 相互独立：每个渲染进程都是独立的，这意味着就算它们某个崩溃了，也不会影响其余的渲染进程。 隐藏的：你可以设置一个窗口是隐藏的，然后让它只在背后执行代码（👍）。 把它们想象成这样在 Chrome（或其它浏览器）中的每个标签页（tab） 和其内的页面，就好比 Electron 中的一个单独渲染进程。如果你关闭所有标签页，Chrome 依然存在，这好比 Electron 的主进程，而且你能打开一个新的窗口或关闭这个应用。 注：一般情况下，在 Chrome 浏览器中，一个标签页（tab）中的页面（即除了浏览器本身部分，如搜索框、工具栏等）就是一个渲染进程。 相互通讯尽管主进程和渲染进程都有各自的任务，但它们之间也有需要协同完成的任务。因此它们之间需要通讯。IPC就为此而生，它提供了进程间的通讯。但它只能在主进程与渲染进程之间传递信息。 IPC：主进程和渲染进程都有一个 IPC 模块。 汇成一句话Electron 应用就像 Node 应用，它也依赖一个 package.json 文件。该文件定义了哪个文件作为主进程，并因此让 Electron 知道从何启动你的应用。然后主进程能创建渲染进程，并能使用 IPC 让两者间进行消息传递。 至此，Electron 的基础部分介绍完毕。该部分是基于我之前翻译的一篇文章《Essential Electron》，译文可点击 这里。 Vue 全家桶目前，该工具应用了 Vue、Vuex、Vuex-router。在工具基本定型阶段，由 1.x 升级到了 2.0 （Vuex 暂未升级）。 为什么选择 Vue对于我来说： 简单易用，一般使用只需看官方文档。 数据驱动视图，所以基本不用操作 DOM 了。 框架的存在是为了帮助我们应对复杂度。 全家桶的好处是：对于一般场景，我就不需要考虑用哪些个库（插件）。 Vue 1.x -&gt; Vue 2.0 的版本迁移用 vue-migration-helper 即可分析出大部分需要更改的地方。 网上已经有很多关于 Vue 的信息了。至此，Vue 部分介绍完毕。 js-xlsx该库支持各种电子表格格式的解析和生成。它由纯 JavaScript 实现，适用于前端和 Node。详情&gt;&gt; 支持读入的格式有： Excel 2007+ XML Formats (XLSX/XLSM) Excel 2007+ Binary Format (XLSB) Excel 2003-2004 XML Format (XML “SpreadsheetML”) Excel 97-2004 (XLS BIFF8) Excel 5.0/95 (XLS BIFF5) OpenDocument Spreadsheet (ODS) 支持写的格式有： XLSX CSV (and general DSV) JSON and JS objects (various styles) 只要能提供读（解析）和写，剩下的就是靠 JavaScript 处理解析出来的数据（JSON）了。目前该库提供了 sheet_to_json 方法，该方法能将读入的 Excel 数据转为 JSON 格式。由于导出时需要提供特定的 JSON 格式，因此这部分需要我们自己实现。 更多关于 Excel 在 JavaScript 中处理的知识可关注：凹凸实验室的《Node读写Excel文件探究实践》。但该文章存在两处问题（均在 js-xlsx 实战的导出表格部分）： 生成头部时，Excel 的列信息简单地通过 String.fromCharCode(65+j) 生成，但列大于 26 时就会出现问题。这个问题会在后面章节中给出解决方案； 转换成 worksheet 需要的结构处，出现逻辑性错误，并且会导致严重的性能问题。逻辑问题在此不讲述，我们讲下性能问题：ECMAScript 的不断更新，让 JavaScript 更加强大和易用。尽管如此，我们还是要做到『物尽所用』，而不要『大材小用』，否则会得到反效果。这里导致性能问题的正是 Object.assign() 方法，该方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。由于该方法自身的实现机制，会在这里产生大量的冗余操作。而这里的单元格信息是唯一的，所以直接通过 forEach 为一个空对象赋值即可。提升 N 倍性能的同时，也把逻辑性错误解决了。 原来的：1var result = 某数组.reduce((prev, next) =&gt; Object.assign(&#123;&#125;, prev, &#123;[next.position]: &#123;v: next.v&#125;&#125;), &#123;&#125;); 改为：1var result = 某数组.forEach((v, i) =&gt; data[v.position]= &#123;v: v.v&#125;) 实践是检验真理的唯一标准在理解上述知识的前提下，下面就谈谈一些在实践中总结出来的技巧、难点和重点。 CSS、JavaScript 和 Electron 相关的知识和技巧高亮 table 的列Excel 单元格采用 table 展示。在 Excel 中，被选中的单元格会高亮相应的『行』和『列』，以提醒用户。在该应用中也有做相应处理，横向高亮采用 tr:hover 实现，而纵向呢？这里所采用的一个技巧是： 假设 HTML 结构如下：1234div.container table tr td CSS 代码如下：12345678910.container &#123; overflow:hidden; &#125;td &#123; position: relative; &#125;td:hover::after &#123; position: absolute; left: 0; right: 0; top: -1个亿px; // 小目标达成，不过是负的😭 bottom: -1个亿px; z-index: -1; // 避免遮住自身和同列 td 的内容、border 等&#125; 斜分割线如图： 分割线可以通过 ::after/::before 伪类元素实现一条直线，然后通过 transform:rotate(); 旋转特定角度实现。但这种实现的一个问题是：由于宽度是不定的，因此需要通过 JavaScript 运算才能得到准确的对角分割线。 因此，这里可以通过 CSS 线性渐变 linear-gradient(to top right, transparent, transparent calc(50% - .5px), #d3d6db calc(50% - .5px), #d3d6db calc(50% + .5px), transparent calc(50% + .5px)) 实现。无论宽高如何变，依然妥妥地自适应。 Excel 的列转换 Excel 的列需要用『字母』表示，但不能简单地通过 String.fromCharCode() 实现，因为当超出 26列 时会产生问题（如：第 27 列，String.fromCharCode(65+26) 得到的是 [，而不是 AA）。因此，这需要通过『十进制和26进制转换』算法来实现。 123456789101112// 将指定的自然数转换为26进制表示。映射关系：[0-25] -&gt; [A-Z]。function getCharCol(n) &#123; let temCol = '', s = '', m = 0 while (n &gt; 0) &#123; m = n % 26 + 1 s = String.fromCharCode(m + 64) + s n = (n - m) / 26 &#125; return s&#125; 1234567891011// 将指定的26进制转换为自然数。映射关系：[A-Z] -&gt;[0-25]。function getNumCol(s) &#123; if (!s) return 0 let n = 0 for (let i = s.length - 1, j = 1; i &gt;= 0; i--, j *= 26) &#123; let c = s[i].toUpperCase() if (c &lt; 'A' || c &gt; 'Z') return 0 n += (c.charCodeAt() - 64) * j - 1 &#125; return n&#125; 为 DOM 的 File 对象增加了 path 属性Electron 为 File 对象额外增了 path 属性，该属性可得到文件在文件系统上的真实路径。因此，你可以利用 Node 为所欲为😈。应用场景有：拖拽文件后，通过 Node 提供的 File API 读取文件等。 支持常见的编辑功能，如粘贴和复制Electron 应用在 MacOS 中默认不支持『复制』『粘贴』等常见编辑功能，因此需要为 MacOS 显式地设置复制粘贴等编辑功能的菜单栏，并为此设置相应的快捷键。 123456789101112131415161718192021222324252627282930313233343536373839404142// darwin 就是 MacOSif (process.platform === 'darwin') &#123; var template = [&#123; label: 'FromScratch', submenu: [&#123; label: 'Quit', accelerator: 'CmdOrCtrl+Q', click: function() &#123; app.quit(); &#125; &#125;] &#125;, &#123; label: 'Edit', submenu: [&#123; label: 'Undo', accelerator: 'CmdOrCtrl+Z', selector: 'undo:' &#125;, &#123; label: 'Redo', accelerator: 'Shift+CmdOrCtrl+Z', selector: 'redo:' &#125;, &#123; type: 'separator' &#125;, &#123; label: 'Cut', accelerator: 'CmdOrCtrl+X', selector: 'cut:' &#125;, &#123; label: 'Copy', accelerator: 'CmdOrCtrl+C', selector: 'copy:' &#125;, &#123; label: 'Paste', accelerator: 'CmdOrCtrl+V', selector: 'paste:' &#125;, &#123; label: 'Select All', accelerator: 'CmdOrCtrl+A', selector: 'selectAll:' &#125;] &#125;]; var osxMenu = menu.buildFromTemplate(template); menu.setApplicationMenu(osxMenu);&#125; 更贴近原生应用Electron 的一个缺点是：即使你的应用是一个简单的时钟，但它也不得不包含完整的基础设施（如 Chromium、Node 等）。因此，一般情况，打包后的程序至少会达到几十兆（根据系统类型进行浮动）。当你的应用越复杂，就越可以忽略这部分了。 众所周知，页面的渲染难免会导致『白屏』，而且这里采用了 Vue 框架，情况就更加糟糕了。另外，Electron 应用也避免不了『先打开浏览器，再渲染页面』的步骤。下面提供几种方法来减轻这种情况，以让程序更贴近原生应用。 指定 BrowserWindow 的背景颜色； 先隐藏窗口，直到页面加载后再显示； 保存窗口的尺寸和位置，以让程序下次被打开时，依然保留的同样大小和出现在同样的位置上。 对于第一点，若程序的背景不是纯白（#fff）的，那么可指定窗口的背景颜色与其一致，以避免突变。1234mainWindow = new BrowserWindow(&#123; title: 'XCel', backgroundColor: '#f5f5f5',&#125;; 对于第二点，由于 Electron 本质是一个浏览器，需要加载非网页部分的资源。因此，我们可以先隐藏窗口。1234var mainWindow = new BrowserWindow(&#123; title: 'ElectronApp', show: false,&#125;; 等到渲染进程开始渲染页面的那一刻，在 ready-to-show 的回调函数中显示窗口。1234mainWindow.on('ready-to-show', function() &#123; mainWindow.show(); mainWindow.focus();&#125;); 对于第三点，我并没有实现，原因如下： 用户一般是根据当时的情况对程序的尺寸和位置进行调整，即视情况而定。 以上是我个人臆测，主要是我懒🐶。 其实现方式，可参考《4 must-know tips for building cross platform Electron apps》。 如何在渲染进程调用原生弹框？在渲染进程中调用原本专属于主进程中的 API （如弹框）的方式有两种： IPC 通讯模块：先在主进程通过 ipcMain 进行监听，然后在渲染进程通过 ipcRenderer 进行触发； remote 模块：该模块提供了一种在渲染进程（网页）和主进程之间进行进程间通讯（IPC）的简便途径。 对于第一种，有需要就在评论区留言； 对于第二种， 在渲染进程中，运行以下代码即可：123456789 const remote = require('electron').remote remote.dialog.showMessageBox(&#123; type: 'question', buttons: ['不告诉你', '没有梦想'], defaultId: 0, title: 'XCel', message: '你的梦想是什么？'&#125; 自动更新如果 Electron 应用没有了自动更新的功能，那么意味着用户想体验你新开发的功能或用上修复 Bug 后的新版本，只能靠自己主动地去官网下载，这无疑是糟糕的体验。Electron 提供的 autoUpdater 模块可实现自动更新功能，该模块提供了第三方框架 Squirrel 的接口，但 Electron 目前只内置了 Squirrel.Mac，且它与 Squirrel.Windows（需要额外引入）的处理方式也不一致（在客户端与服务器端两方面），因此如果刚接触该模块，会发现处理起来相对比较繁琐。具体可以参考我的一篇译文《Electron 自动更新的完整教程（Windows 和 OSX）》。 目前 Electron 的 autoUpdater 模块不支持 Linux 系统。 另外，XCel 目前并没有采用 autoUpdater 模块实现自动更新功能，而是利用 Electron 的 DownloadItem 模块实现。而服务器端则采用 Nuts。 为 Electron 应用生成 Windows 安装包通过 electron-builder 即可直接生成常见的 MacOS 安装包，但它生成的 Windows 的安装包却略显简洁。 Mac 常见的安装模式，将“左侧的应用图标”拖拽到“右侧的 Applications”即可 通过 electron-builder 生成的 Windows 安装包与我们在 Windows 上常见的软件安装界面不太一样，它没有安装向导和点击“下一步”的按钮，只有一个安装时的 gif 动画（默认的 gif 动画如下图，当然你也可以指定特定的 gif 动画），因此也就没有让用户选择安装路径等权利。 Windows 安装时 默认显示的 gif 动画 如果你想为打包后的 Electron 应用（即通过 electron-packager/electron-builder 生成的 、可直接运行的程序目录）生成需要点击“下一步”和可让用户指定安装路径的常见安装包，可以通过 NSIS 程序，具体可看这篇教程 《[教學]只要10分鐘學會使用 NSIS 包裝您的桌面軟體–安裝程式打包。完全免費。》。 NSIS（Nullsoft Scriptable Install System）是一个开源的 Windows 系统下安装程序制作程序。它提供了安装、卸载、系统设置、文件解压缩等功能。这如其名字所指出的那样，NSIS 是通过它的脚本语言来描述安装程序的行为和逻辑的。NSIS 的脚本语言和通常的编程语言有类似的结构和语法，但它是为安装程序这类应用所设计的。 至此，CSS、JavaScript 和 Electron 相关的知识和技巧 部分阐述完毕。 性能优化下面谈谈『性能优化』，这部分涉及到运行效率和内存占用量。注：以下内容均基于 Excel 样例文件（数据量为：1913 行 x 180 列）得出的结论。 执行效率和渲染的优化Vue 性能真的好？Vue 一直标榜着自己性能优异，但当数据量上升到一定量级时（如 1913 x 180 ≈ 34 万个数据单元），会出现严重的性能问题（不做相应优化的前提下）。 如直接通过列表渲染 v-for 渲染数据时，会导致程序卡死。答：通过查阅相关资料可得（猜测）， v-for 是通过一条条数据在构建后插入 DOM 的，这对于数据量较大时，无疑会造成严重的性能问题。 当时，我想到了两种解决思路： Vue 是数据驱动视图的，对数据分段 push，即将一个庞大的任务分割为 N 份。 自己拼接 HTML 字符串，再通过 innerHTML 一次性插入。 最终，我选择了第二条，理由是： 性能最佳，因为每次执行数据过滤时，Vue 都要进行 diff，性能不佳。 更符合当前应用的需求：纯展示且无需动画过渡等。 实现更简单 将原本繁重的 DOM 操作转移到了 JavaScript 的拼接字符串后，性能得到了很大提升（不会导致程序卡死而渲染不出视图）。这种实现原理难道不就是 Vue、React 等框架解决的问题之一吗？只不过框架考虑的场景更广，有些地方需要我们自己根据实际情况进行优化而已。 在浏览器当中，JavaScript 的运算在现代的引擎中非常快，但 DOM 本身是非常缓慢的东西。当你调用原生 DOM API 的时候，浏览器需要在 JavaScript 引擎的语境下去接触原生的 DOM 的实现，这个过程有相当的性能损耗。所以，本质的考量是，要把耗费时间的操作尽量放在纯粹的计算中去做，保证最后计算出来的需要实际接触真实 DOM 的操作是最少的。 —— 《Vue 2.0——渐进式前端解决方案》 当然，由于 JavaScript 天生单线程，即使执行数速度再快，也会导致页面有短暂的时间拒绝用户的输入。此处可通过 Web Worker 或其它方式解决，这也将是我们后续讲到的问题。 也有网友提供了优化大量列表的方法：https://clusterize.js.org/。 但在这里我并没有采用此方式。 强大的 GPU 加速插入 DOM 后，又会出现了另外一个问题：滚动会很卡。猜想这是渲染问题，毕竟 34 万个单元格同时存在于界面中。 添加 transform: translate3d(0, 0, 0) / translateZ(0) 属性启动 GPU 渲染，即可解决这个渲染性能问题。再次感叹该属性的强大。🐂 后来，考虑到用户并不需要查看全部数据，只需展示部分数据让用户进行参考即可。我们对此只渲染前 30/50 行数据。这样即可提升用户体验，也能进一步优化性能（又是纯属臆测）。 记得关闭 Vuex 的严格模式另外，由于自己学艺不精和粗心大意，忘记在生产环境关闭 Vuex 的『严格模式』。Vuex 的严格模式要在生产中关闭，否则会对 state 树进行一个深观察 (deep watch)，产生不必要的性能损耗。也许在数据量少时，不会注意到这个问题。 我当时的情况是：导入 Excel 数据后，再进行交互（涉及 Vuex 的读写操作），则需要等几秒才会响应，而直接通过纯 DOM 监听的事件则无此问题。由此，判断出是 Vuex 问题。 1234const store = new Vuex.Store(&#123; // ... strict: process.env.NODE_ENV !== 'production'&#125;) 多进程！！！前面说道，JavaScript 天生单线程，即使再快，对于需要处理数据量较大的情况，也会出现拒绝响应的问题。因此需要 Web Worker 或类似的方案去解决。 在这里我不选择 Web worker 的原因有如下几点： 有其它更好的替代方案：一个主进程能创建多个渲染进程，通过 IPC 即可进行数据交互； Electron 不支持 Web Worker！ Electron 作者在 2014.11.7 在《state of web worker support?》 issue 中回复了以下这一段： Node integration doesn’t work in web workers, and there is no plan to do. Workers in Chromium are implemented by starting a new thread, and Node is not thread safe. Back in past we had tried to add node integration to web workers in Atom, but it crashed too easily so we gave up on it. 因此，我们最终采用了创建一个新的渲染进程 background process 进行处理数据。由 Electron 章节可知，每个 Electron 渲染进程是独立的，因此它们不会互相影响。但这也带来了一个问题：它们不能相互通讯？ 错！下面有 3 种方式进行通讯： Storage API：对某个标签页的 localStorage/sessionStorage 对象进行增删改时，其他标签页能通过 window.storage 事件监听到。 IndexedDB：IndexedDB 是一个为了能够在客户端存储可观数量的结构化数据，并且在这些数据上使用索引进行高性能检索的 API。 通过主进程作为中转站：设主界面的渲染进程是 A，background process 是 B，那么 A 先将 Excel 数据传递到主进程，然后主进程再转发到 B。B 处理完后再原路返回，具体如下图。当然，也可以将数据存储在主进程中，然后在多个渲染进程中使用 remote 模块来访问它。 该工具采用了第三种方式的第一种情况： 1、主页面渲染进程 A 的代码如下：1234567891011//①ipcRenderer.send('filter-start', &#123; filterTagList: this.filterTagList, filterWay: this.filterWay, curActiveSheetName: this.activeSheet.name&#125;)// ⑥ 在某处接收 filter-response 事件ipcRenderer.on(\"filter-response\", (arg) =&gt; &#123; // 得到处理数据&#125;) 2、作为中转站的主进程的代码如下：12345678910//②ipcMain.on(\"filter-start\", (event, arg) =&gt; &#123; // webContents 用于渲染和控制 web page backgroundWindow.webContents.send(\"filter-start\", arg)&#125;)// ⑤ 用于接收返回事件ipcMain.on(\"filter-response\", (event, arg) =&gt; &#123; mainWindow.webContents.send(\"filter-response\", arg)&#125;) 3、处理繁重数据的 background process 渲染进程 B 的代码如下：12345678910// ③ipcRenderer.on('filter-start', (event, arg) =&gt; &#123; // 进行运算 ... // ④ 运算完毕后，再通过 IPC 原路返回。主进程和渲染进程 A 也要建立相应的监听事件 ipcRenderer.send('filter-response', &#123; filRow: tempFilRow &#125;)&#125;) 至此，我们将『读取文件』、『过滤数据』和『导出文件』三大耗时的数据操作均转移到了 background process 中处理。 这里，我们只创建了一个 background process，如果想要做得更极致，我们可以新建『CPU 线程数- 1 』 个的 background process 同时对数据进行处理，然后在主进程对处理后数据进行拼接，最后再将拼接后的数据返回到主页面的渲染进程。这样就可以充分榨干 CPU 了。当然，在此我不会进行这个优化。 不要为了优化而优化，否则得不偿失。 —— 某网友 内存占有量过大解决了执行效率和渲染的问题，发现也存在内存占用量过大的问题。当时猜测是以下几个原因： 三大耗时操作均放置在 background process 处理。在通讯传递数据的过程中，由于不是共享内存（因为 IPC 是基于 Socket 的），导致出现多份数据副本（在写该篇文章时才有了这相对确切的答案）。 Vuex 是以一个全局单例的模式进行管理，但它会是不是对数据做了某些封装，而导致性能的损耗呢？ 由于 JavaScript 目前不具有主动回收资源的能力，所以只能主动对闲置对象设置为 null，然后等待 GC 回收。 由于 Chromium 采用多进程架构，因此会涉及到进程间通信问题。Browser 进程在启动 Render 进程的过程中会建立一个以 UNIX Socket 为基础的 IPC 通道。有了 IPC 通道之后，接下来 Browser 进程与 Render 进程就以消息的形式进行通信。我们将这种消息称为 IPC 消息，以区别于线程消息循环中的消息。——《Chromium的IPC消息发送、接收和分发机制分析》 定义：为了易于理解，以下『Excel 数据』均指 Excel 的全部有效单元格转为 JSON 格式后的数据。 最容易处理的无疑是第三点，手动将不再需要的变量及时设置为 null。但这效果并不明显。 后来，通过系统的『活动监视器』对该工具的每阶段（打开时、导入文件时、筛选时和导出时）进行粗略的内存分析，得到以下报告（之前分析的、未作修改）： —————- S：报告分割线 —————-经观察，主要耗内存的是页面进程。下面通过截图说明：PID 15243 是主进程PID 15246 是页面渲染进程PID 15248 是 background 渲染进程 a、首次启动程序时（第 4 行是主进程；第 1 行是页面渲染进程；第 3 行是 background 渲染进程 ） b、导入文件（第 5 行是主进程；第 2 行是页面渲染进程；第 4 行是 background 渲染进程 ） c、筛选数据（第 4 行是主进程；第 1 行是页面渲染进程；第 3 行是 background 渲染进程 ） 由于 JS 目前不具有主动回收资源的功能，所以只能主动将对象设置为 null，然后等待 GC 回收。 因此，经过一段时间等待后，内存占用如下：d、一段时间后（第 4 行是主进程；第 1 行是页面渲染进程；第 3 行是 background 渲染进程 ） 由上述可得，页面渲染进程由于页面元素和 Vue 等 UI 相关资源是固定的，占用内存较大且不能回收。主进程占用资源也不能得到很好释放，暂时不知道原因，而 background 渲染进程则较好地释放资源。 —————- E：报告分割线 —————- 根据报告，初步得出的结论是 Vue 和通讯时占用资源较大。 根据该工具的实际应用场景：由于 Excel 数据只在『导入』和『过滤后』两个阶段需要展示，而且展示的只是通过 JavaScript 拼接的 HTML 字符串构成的 DOM 而已。因此将表格数据放置在 Vuex 中，有点滥用资源的嫌疑。 另外，在 background process 中也有存有一份 Excel 数据副本。因此，索性只在 background process 存储一份 Excel 数据，然后每当数据变化时，通过 IPC 让 background process 返回拼接好的 HTML 字符串即可。这样一来，内存占有量立刻下降许多。而且这也是一个一举多得的优化： 字符串拼接操作也转移到了 background process，页面的渲染进程进一步减少耗时的操作； 内存占有量大大减小，响应速度也得到了提升。 其实，这也有点像 Vuex 的『全局单例模式管理』，一份数据就好。 当然，对于 Excel 的基本信息，如行列数、SheetName、标题组等均依然保存在 Vuex。 优化后的内存占有量如下图。与上述报告的第三张图相比（同一阶段），内存占有量下降了 44.419%：另外，对于不需要响应的数据，可通过 Object.freeze() 冻结起来。这也是一种优化手段。但该工具目前并没有应用到。 至此，优化部分也阐述完毕了！ 该工具目前是开源的，欢迎大家使用或推荐给用研组等有需要的人。 你们的反馈（可提交 issues / pull request）能让这个工具在使用和功能上不断完善。 最后，感谢 LV 的产品规划、界面设计和优化上的强力支持。全文完！","pubDate":"Tue, 15 Nov 2016 15:23:23 GMT","guid":"https://aotu.io/notes/2016/11/15/xcel/","category":"项目总结"},{"title":"漫漫编程路上必读的7本书","link":"https://aotu.io/notes/2016/11/14/booklist-for-every-programmer/","description":"7本对提升程序员编程思想、软件工程理论大有裨益的通用读物，不分专业，不分语言，不分排名先后。 Code Complete中文版叫『代码大全』，两届SoftwareJolt Award震撼大奖得主，一本完整的软件构建手册，涵盖了软件构建过程中的所有细节。 谷歌度娘搜关键字「程序员必读书本」的结果统计，这本书是最多人推荐的，近年宣称为「最值得程序员阅读的首本书，也是建议程序员推荐给身边小伙伴的首本书」。 想读的朋友可以到我东东家购买， 代码大全（第2版 英文版） 代码大全（第2版 中文版） The Pragmatic Programmer - From Journeyman to Master中文版叫『程序员修炼之道-从小工到专家』。 原版略贵但绝对值的一读，它充满了关于如何改进程序员本身和代码本身的实用建议。 想读的朋友依然可以到我东东家购买，原版有每满100减30的活动。 程序员修炼之道 英文版） 程序员修炼之道（第2版 中文版） The Mythical Man-Month: Essays on Software Engineering有一个好的中文名叫『人月神话』。 引用东东家的一段广告语吧： 图灵奖得主，IBM 360系统之父，作者Brooks颠覆了项目管理领域，长久不衰传奇著作！软件开发人员、软件项目经理、系统分析师等IT从业者必藏之软工圣经，畅销40年！赠国内实战体验精华册 然后摘其中的两句经典： 生一个孩子总是需要九个月的时间，不管安排多少个女性。一个煎蛋，承诺在两分钟内完成，但如果两分钟后还是没有准备好，那么客户有两种选择——等待或吃半熟品，软件客户也只能这样选择。 正从标题中所说的那样，这是一本关于软件工程的散文集，文辞优美。唯一的缺点就是引用了年迈的古老技术，但是，这并不影响这本书的魅力。 是时候入手一本经典书籍了： 人月神话 英文版） 人月神话（40周年中文纪念版） Structure and Interpretation of Computer Programs中文名叫『计算机程序的构造和解释』，目测应该是一本计算机科学的科普读物。 京东购买地址： 计算机程序的构造和解释 英文版） 计算机程序的构造和解释 原书第2版 Head First Design Patterns看着封面的妹子就想读的一本书，中文名叫『Head Frirst 设计模式』。 看上去最不像技术的编程书籍！ 每个页面都包含涂鸦、图片以及其他一些吸引眼球的东西。 可能给人的印象是一本阅读起来很轻松的书，但事实上它会讨论编程的一些核心主题 —— 设计模式。 设计模式就是编程世界里的各种抽象的定理，而这本书有把它们画出来、具体化了的感觉。 畅销十年，累计印刷30余次，荣获2005年第十五届Jolt通用类图书震撼大奖！买买买！ Head Frirst 设计模式 英文版） O’Reilly：Head First设计模式（中文版） Introduction to Algorithms中文名叫『算法导论』，这是今天介绍的几本书里面唯一一本关于「算法」的。 超过50万人阅读的算法圣经！算法标准教材，国内外1000余所高校采用! 京东购买地址： 算法导论 英文版） 算法导论（中文版） The Clean Coder最后一本是关于程序员职业素养的书，中文名为『程序员的职业素养』。 该书探讨了一些程序员经常忽视的主题。 成为专业的程序员意味着什么？ 如何打磨自己成为一个真正的软件工匠？ 冲突和紧张的日程处理 如何管理你的时间？如何扩张技能？ 何时说“不” 避免倦怠 ..以及更多。 你可能并不总是同意作者的观点，但它提供了良好的精神食粮。这可能并非你所期望的，但可能正是你所需要的。 京东购买地址： 程序员的职业素养 英文版） 程序员的职业素养 中文版 参考资料 Stackoverflow: What is the single most influential book every programmer should read? Recommended Reading for Developers 12 Most Influential Books Every Software Engineer Needs to Read 10 Classic Books Every Serious Developer Should Read 每个程序员应该阅读的10本经典书籍","pubDate":"Mon, 14 Nov 2016 08:21:43 GMT","guid":"https://aotu.io/notes/2016/11/14/booklist-for-every-programmer/","category":"资源合集"},{"title":"Webpack 实用配置技巧","link":"https://aotu.io/notes/2016/11/14/webpack-tips/","description":"前言Webpack做了什么 一句话简单来解释就是处理模块依赖，并将它们合并成可用的静态资源。 为什么选Webpack 模块打包工具有很多，Webpack的特点是它依赖的模块可以是js文件，也可以是css文件，只要配置对应的webpack-loader(加载器)，.coffee、.sass、.jade等等任意的静态资源文件都可以被引用，并解析。 例如：我在项目中使用Vue框架，在配置官方提供的loader后，就可以直接在js中依赖.vue后缀的单文件组件了。 上手安装 使用npm init命令来创建一个package.json文件 安装Webpack，推荐只安装在当前项目中作为依赖 npm install webpack –save 添加一个配置文件 webpack.config.js module.exports = { entry: &quot;./entry.js&quot;, output: { path: __dirname, filename: &quot;bundle.js&quot; }, module: { loaders: [ { test: /\\.css$/, loader: &quot;style!css&quot; } ] } }; 执行webpack命令 如果全局安装了Webpack的话,那么直接在当前项目执行webpack命令就可以依赖上述webpack.config.js文件中的配置，分析entry.js中的依赖，打包输出bundle.js 我使用npm scripts来启动任务，在package.json中添加： { ... &quot;scripts&quot;: { &quot;build&quot;: &quot;NODE_ENV=production webpack --watch&quot; } ... } 执行npm run build。其中–watch参数表示持续的监听文件变化进行打包。 入口文件配置配置多个入口文件 module.exports = { entry: { entry1_bundle: &quot;./entry1.js&quot;, entry2_bundle: &quot;./entry2.js&quot; }, output: { path: __dirname, filename: &quot;[name].js&quot; }, module: { loaders: [ { test: /\\.css$/, loader: &quot;style!css&quot; } ] } }; 在这个配置文件中有两个入口文件，输出的时候[name]会被替换为入口中配置的entry1_bundle和entry2_bundle 使用glob方式配置 var path = require(&apos;path&apos;), glob = require(&apos;glob&apos;) //需安装glob模块依赖 function getEntries (globPath) { var files = glob.sync(globPath); var _entries = {}, entry, dirname, basename; for (var i = 0; i &lt; files.length; i++) { entry = files[i]; dirname = path.dirname(entry); basename = path.basename(entry, &apos;.js&apos;); _entries[path.join(dirname, basename)] = &apos;./&apos; + entry; } return _entries; } 执行getEntries(‘*.js’)就会遍历到目录下全部的js文件做为入口文件配置。 使用插件目前我有用到三个插件：CommonsChunkPlugin，UglifyJsPlugin，以及一个我自己定义的插件 module.exports = { // plugins 字段传入一个数组，里面是实例化后的各种插件 plugins: [new webpack.optimize.CommonsChunkPlugin({ name: &apos;vendor&apos;, minChunks: 3 }), new webpack.optimize.UglifyJsPlugin([options]), ... ], entry: { entry1_bundle: &quot;./entry1.js&quot;, entry2_bundle: &quot;./entry2.js&quot; }, ... }; 提取公用资源 为了便于使用缓存，我通过CommonsChunkPlugin这个插件将公用部分提取出来。 上述配置会自动的将被3个及以上入口文件引用的资源提取出来到一个新的文件vendor.js中。我们通常不希望公用的内容发生不预知的变化，这样配置就可以将希望提取出来的内容显性的配置在config文件中： entry: { vendor: [&quot;vue&quot;, &quot;other-lib&quot;], ... } new CommonsChunkPlugin({ name: &quot;vendor&quot;, // 将minChunks设置为无穷大，就不会有不期望的内容进入vendor了 minChunks: Infinity, }) 只在生产环境下启用UglifyJs插件 var plugins = [new webpack.optimize.CommonsChunkPlugin([options])] // npm scripts 配置的参数可以用上了 if(process.env.NODE_ENV == &apos;production&apos;){ plugins.push(new webpack.optimize.UglifyJsPlugin({ compress: { warnings: false } })) } 关于UglifyJs的使用就不介绍了，参考UglifyJS2。 自定义插件 Webpack提供的插件已足够使用，不过针对不同的业务，我们可能需要定制一些功能，例如我所定制的功能就是在编译资源的同时生成一份用于上传到服务器的md5版本号配置文件。 来一个简单的小栗子，如何开始写一个Webpack插件： var chunkCombo = function(){}; chunkCombo.prototype.apply = function(compiler, callback){ compiler.plugin(&quot;emit&quot;, function(compilation, callback){ compilation.chunks.map(function(chunk, key){ var filename = chunk.name + &apos;.shtml&apos;; var content = chunk.hash.slice(0,8); // 生成一个对应的新文件存储md5值 compilation.assets[filename] = { source: function() { return content; }, size: function() { return Buffer.byteLength(content, &apos;utf8&apos;) } }; }) callback(); }); } 随着项目的深度定制和优化，我们可能需要开发更多的插件。 配置loaders有了无所不能的加载器，Webpack可以处理任何类型的静态文件 module.exports = { entry: { entry1_bundle: &quot;./entry1.js&quot;, entry2_bundle: &quot;./entry2.js&quot; }, output: { path: __dirname, filename: &quot;[name].js&quot; }, module: { loaders: [ { test: /\\.vue$/, loader: &apos;vue-loader&apos; }, { test: /\\.css$/, loader: &apos;style-loader!css-loader&apos; }, { test: /\\.js$/, exclude: /node_modules/, loader: &quot;babel-loader&quot;}, //加载器之间用！连接，-loader可以省略不写 { test: /\\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;}, { test: /\\.(png|jpg)$/, loader: &apos;url-loader?limit=8192&apos;} ] } }; 加载器使用前记得先通过npm安装对应的模块，并将依赖添加到package.json文件中，例如： npm install vue-loader --save vue-loader用于解析.vue单文件组件。 有了babel-loader就可以直接使用新的语法特性了。Babel的配置参见Using Babel 使用webpack-dev-serverwebpack-dev-server是一个轻量的node.js Express服务，通过Socket.IO来实时的通知客户端Webpack编译状态。安装webpack-dev-server模块，此处不再重复，直接看配置文件： module.exports = { entry: { entry1_bundle: &quot;./entry1.js&quot;, entry2_bundle: &quot;./entry2.js&quot; }, output: { path: __dirname, filename: &quot;bundle.js&quot; }, ... devServer: { // serve 的根目录 contentBase: _contentBase, port: 9000, // iframe模式和inline模式可选 inline: true， ... } }; 在package.json中添加： { ... &quot;scripts&quot;: { &quot;dev&quot;: &quot;NODE_ENV=dev webpack-dev-server&quot; } ... } 执行npm run dev 命令后，服务就启动了。访问http://localhost:9000，就可以看到你的应用了。 定制Express路由 在inline模式下，需要手动的将用于更新的的脚本引入到页面中： module.exports = { entry: { entry1_bundle: &quot;./entry1.js&quot;, entry2_bundle: &quot;./entry2.js&quot; }, output: { path: __dirname, filename: &quot;bundle.js&quot; }, ... devServer: { // serve 的根目录 contentBase: _contentBase, port: 9000, // iframe模式和inline模式可选 inline: true, setup: function(app) { app.use(function(req, res, next) { //... return next(); }); app.get([&apos;*.shtml&apos;,&apos;*.html&apos;], function(req, res, next) { //... //将实时更新的脚本引入到页面中 res.end(&apos;&lt;script src=&quot;http://localhost:9000/webpack-dev-server.js&quot;&gt;&lt;/script&gt;&apos;) }) } } }; 关于Express路由的使用，参考Express Routing 在我的项目中，我希望HTML页面在开发环境下和服务器环境下保持一致，因此我在devServer中配置了对HTML页面的解析。 以上，希望我的Webpack项目配置能对你解决相关问题的时候有所帮助和启发。 参考资料 Webpack docs Express Routing 使用npm scripts替代gulp","pubDate":"Mon, 14 Nov 2016 08:16:31 GMT","guid":"https://aotu.io/notes/2016/11/14/webpack-tips/","category":"Web开发"},{"title":"WeUI for 小程序 - 为微信小程序量身设计","link":"https://aotu.io/notes/2016/11/10/weui-wxss/","description":"官人你没有走错地方，「WeUI」正式开始支持小程序啦，这是新鲜火辣的、微信官方设计团队为微信小程序量身设计的「WeUI-WXSS」。 概述WeUI 是一套同微信原生视觉体验一致的基础样式库，由微信官方设计团队为微信内网页和微信小程序量身设计，令用户的使用感知更加统一。包含button、cell、dialog、 progress、 toast、article、actionsheet、icon等各式元素。 视觉标准weui-design 预览用微信web开发者工具打开dist目录 使用 组件的wxml结构请看dist/example/下的组件 样式文件可直接引用dist/style/weui.wxss，或者单独引用dist/style/widget下的组件的wxss LicenseThe MIT License(http://opensource.org/licenses/MIT) 请自由地享受和参与开源 贡献如果你有好的意见或建议，欢迎给我们提issue或pull request，为提升微信web体验贡献力量。","pubDate":"Thu, 10 Nov 2016 09:21:43 GMT","guid":"https://aotu.io/notes/2016/11/10/weui-wxss/","category":"Web开发"},{"title":"轻氧 - 2016年末最新款互联网专业资讯 APP","link":"https://aotu.io/notes/2016/11/09/liteo2-app/","description":"又是一年的双11，大家都在割肾剁手买买买，我们凹凸实验室「阿尔法APP突击队」在抖腿码码码。抬价而后打折促销的商家都TMD是《无耻的混蛋》昆丁.2009，而我们只做良心的促销： 一款免费实用开源的APP轻氧 是 凹凸实验室 一不留神上架了的一款互联网技术资讯APP，它囊括了众多知名互联网公司、团队及网站的资讯，让你能一口气把业界最优质的文章读完，只要你愿意。 其实市面上互联网技术资讯这块领域已经有非常多优秀的产品了，例如开发者头条，又如后来居上者 掘金，类似产品之间的竞争异常剧烈，举步唯艰，再做一款类似内容的APP的意义到底有多少，而成功的概率又有多少？ 我们曾经纠结过这些问题，但后来觉得这些纠结有点傻~ 做轻氧的『初心』本来就不是超越，而是在积累和探索。 从业务的层面来看，是为团队积累和探索一款APP从零到设计到上架的整个流程，为下一次（如果有的话）APP研发需求做好流程和技术上的准备。 从专业技术的层面来看，我们是在努力拓宽自己的专业范畴，要知道凹凸这个团队的前身是前端团队，相对匮乏原生应用开发经验，如果团队技术的努力方向是多终端技术体系，是全栈，那末轻氧APP则是印证我们朝这个方向发展、具备全栈开发综合能力的结果。 我们像是在练武，轻氧是我们自创的一门渐进式的武学，谁都无法断言它的厉害与否，因为主创们在不断的努力摸索和改进。 我们没有忘记O2的口号是：Open Oriented，所以「轻氧」年后将会开源，并配套一本总结整个APP项目从零到上架的书籍，记录着轻氧从无到有的套路和心法。希望能帮助到那些想了解和掌握Swift编程、Sketch设计、以及数据库架构及设计相关技能的同学们。 授之以鱼不如授之以渔，为「轻氧」存在的最大意义。 源码届时将托管在github.com/o2team/app，欢迎抢先点赞订阅更新。 致潜在的用户「轻氧」适合什么样的你呢？ 如果你是辣么专情的： 程序员、设计师、产品经理、运营、用研。 但又不失滥情的闷骚： 喜欢搞搞数码搞机、喜欢新鲜应用、脑袋发热准备创业。 那么，这款资讯 App 就是专门为你设计的。 我们为互联网人士准备了多个专业资讯频道，将优质资讯分类呈现。 你可以根据需要选择你喜欢的频道来定制APP的内容。 目前已开通 11 个资讯频道 （一些好玩的频道正在筹备中）： 总之，「轻氧」旨在帮你严肃地提升学术、视界的同时，也可以让你开个小差去猎奇酷玩，嘿嘿。 丰富的资讯源关于APP的内容源，除了凹凸实验室原创资讯外， 我们精心选出了一些知名的 UED 和互联网站点，基于其简易信息聚合协议（RSS），将优质的互联网内容包装和分发，聚集到一个平台。 我们搬运但不盗窃，如果你喜欢，你仍然可以把「轻氧」当成是一款RSS订阅器，尽管我们不止于订阅辣么简单，后续我们APP做开源分享的时候再做深入介绍。 经过一段时间的耕耘，目前已有超过 4k 篇资讯，来自于 40+ 资讯来源： 未来，我们还将在保证高质量文章的基础上，聚合更多的来源。 看你喜欢看的就像其它资讯平台一样，「轻氧」的每篇文章也被打上了标签。用户可以根据标签或者来源，能筛选出自己喜欢的内容，定制个性化的时间线。 技术驱动研发与一般的资讯 APP 不同的是，这是一款「技术驱动」的APP，它的诞生源于「工科男」心底纯粹的技术欲望，尽管主创之一是兽医出身。 于是两三个技术工程师包揽了从产品构思、基于 Flinto 的原型交互、基于 Sketch 的视觉设计（除了LOGO为一个视觉美眉支持外）、基于 Swift3.x 的编码实现，当然还有 LeanCloud 数据服务的应用，Linux 服务器运维，以及应用上架部署的所有工作。 这肯定不是一款完美的产品，但我们在不停的迭代完善。 为了进一步提升APP的整体体验、提升我们工程师在跨专业领域的专业度，下一个大版本计划会邀请专业的交互设计师、视觉设计师参与进来。 实验性的UI交互在「轻氧」APP里面，我们无所不能为，实验了一些我们YY觉得酷的体验，例如阅读进度记录、卡片频道。尽管新奇不一定是最合适的，但还是期待能给使用「轻氧」的你带来不一样的资讯阅读体验。 尝鲜下载体验 目前仅提供ios版本基于 React Native 的 Android 版与网页版正在紧急开发中，敬请期待。 官网地址：https://app.aotu.io 下载地址： 扫二维码： 问题反馈： 「凹凸实验室」公众号 (AOTULabs) APP 个人中心 -&gt; 设置 -&gt; 意见反馈 希望在这个信息爆炸的时代，「轻氧」能够帮助你聚焦更优质的资讯内容。也让你更加专注于用心被创造出来的文章，和其创造者。","pubDate":"Wed, 09 Nov 2016 06:21:43 GMT","guid":"https://aotu.io/notes/2016/11/09/liteo2-app/","category":"移动开发"},{"title":"深入了解font-weight","link":"https://aotu.io/notes/2016/11/08/css3fontweight/","description":"问题提出font-weight的属性值有100、200、300、400、500、600、700、800、900和normal、bold、lighter、bolder，它们的区别是？另外，在实际开发中，我们应该使用数值表达还是文字表达呢？ 认识font-weight根据W3C Fonts节章的规范标准，可知： font-weight可取值：100～900和normal、bold、bolder、lighter。 100～900、normal、bold如果字体使用九阶有序数值100～900来划分其字重(字体的粗细度)，那么样式指定的font-weight属性值与字体的字重则一一对应。并且normal等价于400，bold等价于700。但实际上，我们一般遇到的字体很多时候都是使用一些通用的词描述划分其字重，如下所示。 常见的字重数值大致对应的字重描述词语： 100 - Thin 200 - Extra Light (Ultra Light) 300 - Light 400 - Regular (Normal、Book、Roman) 500 - Medium 600 - Semi Bold (Demi Bold) 700 - Bold 800 - Extra Bold (Ultra Bold) 900 - Black (Heavy) 为什么说大致对应呢？在有些字库下是有差异的，比如在Adobe Typekit字库中对字重描述的划分列表中，它列出Heavy指的是800而不是900。另外，在我们日常使用的Photoshop和Sketch里面，Ultra Light是100，而Thin是200。 并且，字体所拥有的字重的数量实际上很少存在满足有9个字重刚好跟100～900的CSS字重一一对应的情况，通常字体拥有的字重数量为4至6个。不必担心，起码400和700对应的字重至少是每种字体必备的，譬如常见的 Arial、Helvetica、Georgia等等，只有400(normal)和700(bold)。 bolder、lighterbolder、lighter表示其字重值是基于从其父元素继承而来的字重计算所得的，与normal、bold所代表的字重并无关系。 其值通常是根据下表计算而得的： 继承值（Inherited value） bolder所代表的字重 lighter所代表的字重 100 400 100 200 400 100 300 400 100 400 700 100 500 700 100 600 900 400 700 900 400 800 900 700 900 900 700 字体匹配算法在上面我们已经提到，在很多情况下，字体并不是以九阶数值来划分的，并且其含有的字重数量是不一的，通常情况下为4-6个。 此时，就会出现样式指定的字重数值在字体中找不到直接对应的字重，那浏览器是如何解决的呢？ Bingo！那就是要靠字体匹配算法来解决。其中关于font-weight部分是这么提及到的： 讲人话就是：如果指定的font-weight数值，即所需的字重，能够在字体中找到对应的字重，那么就匹配为该对应的字重。否则，使用下面的规则来查找所需的字重并渲染： 如果所需的字重小于400，则首先降序检查小于所需字重的各个字重，如仍然没有，则升序检查大于所需字重的各字重，直到找到匹配的字重。 如果所需的字重大于500，则首先升序检查大于所需字重的各字重，之后降序检查小于所需字重的各字重，直到找到匹配的字重。 如果所需的字重是400，那么会优先匹配500对应的字重，如仍没有，那么执行第一条所需字重小于400的规则。 如果所需的字重是500，则优先匹配400对应的字重，如仍没有，那么执行第一条所需字重小于400的规则（感谢@浅夏莜韵的指正）。 感谢来自@何洋的补充：大多数浏览器已实现font-synthesis属性，使用该属性可以控制在font-weight没有相匹配的font typeface时，会模拟计算出合适的渲染字重(与其应有的typeface有些差异)，从而忽略Font Matching Algorithm。参考文章： Fonts－字体匹配算法第5条 MDN－font-synthesis 理解与运用下面我们通过官方例子和实际测试来好好理解这个匹配算法规则。 官方例子W3C规范标准中给出这么一个例子： 注解：灰色标记的是字体中缺少的字重，而黑色则是字体拥有的字重。 基于匹配算法规则，看图理解所得：Figure 15.图指的是 字体库内直接匹配的字重 填空值(即通过算法间接匹配所得字重) 400 300、200、100、500 700 600 900 800 拿font-weight: 300;来说，字体中没有可以直接匹配的字重，那么300小于400，则根据第一条规则，先降序查找匹配，但是都没有可匹配的200、100，那么升序查找为400，结果可匹配。 Figure 16.图指的是 字体库内直接映射的字重 填空值 300 200、100、400、500 600 700、800、900 这里需要注意的是，填空值500表现的是300的字重，而不是600的字重。为什么呢？根据规则，500优先匹配400的字重，但是此处找不到400的字重，则执行规则中第一条所需字重小于400的情况。 其余的，我就不多解释了，大家可以根据结果检查自己是否理解到位。 实际测试——Droid Sans 根据Google Fonts API - Droid Sans提供的Droid Sans字体，我们可以知道该字体拥有两种字重。 根据字体匹配算法规则，我们可以预测其字重匹配应该如下表所示： 字体库内直接映射的字重 填空值 400 300、200、100、500 700 600、800、900 也就是100、200、300、500会表现为跟400同一种字重，600、800、900会表现为跟700同一种字重。 利用Google Fonts提供的Droid Sans，我们进行了实例测试－(DroidSans.html)来验证。结果如下图，证明我们的预测结果正确，该字体匹配算法规则运行有效。 总结根据以上的研究，可以总结出三点： 通常情况下，一个特定的字体仅会包含少数的可用字重。若所指定的字重不存在直接匹配，则会通过字体匹配算法规则匹配使用邻近的可用字重。这也就是为什么我们有时候使用特定字重时没有“生效”，看起来跟其它字重差不多的原因所在。 在实际中，最为常用的字重是normal和bold。我个人认为400、700是等效于normal、bold的，无论哪一种表示方法都没有关系，主要是个人习惯问题。 但是，推荐使用数值替代lighter、bolder，因为这涉及到继承计算的问题，用数值的话则会更为清晰明了。 参考资料：W3C－字体W3C－字体匹配算法","pubDate":"Tue, 08 Nov 2016 08:34:58 GMT","guid":"https://aotu.io/notes/2016/11/08/css3fontweight/","category":"Web开发"}]}